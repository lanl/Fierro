/*****************************************************************************
Â© 2020. Triad National Security, LLC. All rights reserved.
This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos
National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S.
Department of Energy/National Nuclear Security Administration. All rights in the program are
reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear
Security Administration. The Government is granted for itself and others acting on its behalf a
nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare
derivative works, distribute copies to the public, perform publicly and display publicly, and 
to permit others to do so.


This program is open source under the BSD-3 License.
Redistribution and use in source and binary forms, with or without modification, are permitted
provided that the following conditions are met:
    
    1.  Redistributions of source code must retain the above copyright notice, this list of 
        conditions and the following disclaimer.
 
    2.  Redistributions in binary form must reproduce the above copyright notice, this list of 
        conditions and the following disclaimer in the documentation and/or other materials 
        provided with the distribution.
 
    3.  Neither the name of the copyright holder nor the names of its contributors may be used 
        to endorse or promote products derived from this software without specific prior 
        written permission.


THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

**********************************************************************************************/

/**************************************************************************************//**
*  Elements contains many of the basis functions required to implement a wide range of 
*  numerical methods for computational physics. Currently 2D and 3D serendipity basis set 
*  is included, as well as the arbitrary order 2D and 3D tensor product hexahedral elements.
*  There is also a 4D tesseract element that can be used for space-time methods. Make sure 
*  include the elements.h file in your code to access the elememnts library.
*****************************************************************************************/



#include <iostream>  // std::cout etc.
#include <cmath>

#include "utilities.h"
#include "elements.h"

#define EPSILON 1.0e-12

using namespace utils;

namespace elements {

//==============================================================================
//   Function Definitions
//==============================================================================


/**************************************************************************************//**
*  Elements contains many of the basis functions required to implement a wide range of 
*  numerical methods for computational physics. Currently 2D and 3D serendipity basis set 
*  is included, as well as the arbitrary order 2D and 3D tensor product hexahedral elements.
*  There is also a 4D tesseract element that can be used for space-time methods. Make sure 
*  include the elements.h file in your code to access the elememnts library.
*****************************************************************************************/

/*

==========================
Representative Local Cell 
==========================

              K
              ^         J
              |        /
              |       /
                     /
      6------------------7
     /|                 /|
    / |                / |
   /  |               /  |
  /   |              /   | 
 /    |             /    |
4------------------5     |
|     |            |     | ----> I
|     |            |     |  
|     |            |     |
|     |            |     |
|     2------------|-----3
|    /             |    /
|   /              |   /
|  /               |  /
| /                | /         
|/                 |/
0------------------1


patch 0: [0,1,3,2]
patch 1: [4,5,7,6]
patch 2: [0,1,5,4]
patch 3: [2,3,7,6]
patch 4: [0,2,6,4]
patch 6; [1,3,7,5]

*/

// 

/**************************************************************************************//**
*  lobatto_nodes_1D creates nodal positions defined on [-1,1] using the Gauss-Lobatto 
*  quadrature points. The CArray lob_nodes_1D is passed in by reference and modified 
*  in place. The integer num is the numer of points being defined in 1D.
*****************************************************************************************/

void lobatto_nodes_1D(
                      CArray <real_t> &lob_nodes_1D,
                      const int &num){
    if (num == 1){
        lob_nodes_1D(0) = 0.0;
    }
    else if (num == 2){
        lob_nodes_1D(0) = -1.0;
        lob_nodes_1D(1) =  1.0;
    }
    else if (num == 3){
        lob_nodes_1D(0) = -1.0;
        lob_nodes_1D(1) =  0.0;
        lob_nodes_1D(2) =  1.0;
    }
    else if (num == 4){
        lob_nodes_1D(0) = -1.0;
        lob_nodes_1D(1) = -1.0/5.0*sqrt(5.0);
        lob_nodes_1D(2) =  1.0/5.0*sqrt(5.0);
        lob_nodes_1D(3) =  1.0;
    }
    else if (num == 5){
        lob_nodes_1D(0) = -1.0;
        lob_nodes_1D(1) = -1.0/7.0*sqrt(21.0);
        lob_nodes_1D(2) =  0.0;
        lob_nodes_1D(3) =  1.0/7.0*sqrt(21.0);
        lob_nodes_1D(4) =  1.0;
    }
    else if (num == 6){
        lob_nodes_1D(0) = -1.0;
        lob_nodes_1D(1) = -sqrt(1.0/21.0*(7.0 + 2.0*sqrt(7.0)));
        lob_nodes_1D(2) = -sqrt(1.0/21.0*(7.0 - 2.0*sqrt(7.0)));
        lob_nodes_1D(3) =  sqrt(1.0/21.0*(7.0 - 2.0*sqrt(7.0)));
        lob_nodes_1D(4) =  sqrt(1.0/21.0*(7.0 +2.0*sqrt(7.0)));
        lob_nodes_1D(5) =  1.0;
    }
    else if (num == 7){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.830223896278566929872032213967E+00;
        lob_nodes_1D(2) =  - 0.468848793470714213803771881909E+00;
        lob_nodes_1D(3) =    0.0E+00;
        lob_nodes_1D(4) =    0.468848793470714213803771881909E+00;
        lob_nodes_1D(5) =    0.830223896278566929872032213967E+00;
        lob_nodes_1D(6) =    1.0E+00;
    }
    else if (num == 8){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.871740148509606615337445761221E+00;
        lob_nodes_1D(2) =  - 0.591700181433142302144510731398E+00;
        lob_nodes_1D(3) =  - 0.209299217902478868768657260345E+00;
        lob_nodes_1D(4) =    0.209299217902478868768657260345E+00;
        lob_nodes_1D(5) =    0.591700181433142302144510731398E+00;
        lob_nodes_1D(6) =    0.871740148509606615337445761221E+00;
        lob_nodes_1D(7) =    1.0E+00;
    }
    else if (num == 9){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.899757995411460157312345244418E+00;
        lob_nodes_1D(2) =  - 0.677186279510737753445885427091E+00;
        lob_nodes_1D(3) =  - 0.363117463826178158710752068709E+00;
        lob_nodes_1D(4) =    0.0E+00;
        lob_nodes_1D(5) =    0.363117463826178158710752068709E+00;
        lob_nodes_1D(6) =    0.677186279510737753445885427091E+00;
        lob_nodes_1D(7) =    0.899757995411460157312345244418E+00;
        lob_nodes_1D(8) =    1.0E+00;
    }
    else if (num == 10){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.919533908166458813828932660822E+00;
        lob_nodes_1D(2) =  - 0.738773865105505075003106174860E+00;
        lob_nodes_1D(3) =  - 0.477924949810444495661175092731E+00;
        lob_nodes_1D(4) =  - 0.165278957666387024626219765958E+00;
        lob_nodes_1D(5) =    0.165278957666387024626219765958E+00;
        lob_nodes_1D(6) =    0.477924949810444495661175092731E+00;
        lob_nodes_1D(7) =    0.738773865105505075003106174860E+00;
        lob_nodes_1D(8) =    0.919533908166458813828932660822E+00;
        lob_nodes_1D(9) =   1.0E+00;

    }
    else if (num == 11){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.934001430408059134332274136099E+00;
        lob_nodes_1D(2) =  - 0.784483473663144418622417816108E+00;
        lob_nodes_1D(3) =  - 0.565235326996205006470963969478E+00;
        lob_nodes_1D(4) =  - 0.295758135586939391431911515559E+00;
        lob_nodes_1D(5) =    0.0E+00;
        lob_nodes_1D(6) =    0.295758135586939391431911515559E+00;
        lob_nodes_1D(7) =    0.565235326996205006470963969478E+00;
        lob_nodes_1D(8) =    0.784483473663144418622417816108E+00;
        lob_nodes_1D(9) =   0.934001430408059134332274136099E+00;
        lob_nodes_1D(10) =   1.0E+00;
    }

    else if (num == 12){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.944899272222882223407580138303E+00;
        lob_nodes_1D(2) =  - 0.819279321644006678348641581717E+00;
        lob_nodes_1D(3) =  - 0.632876153031869677662404854444E+00;
        lob_nodes_1D(4) =  - 0.399530940965348932264349791567E+00;
        lob_nodes_1D(5) =  - 0.136552932854927554864061855740E+00;
        lob_nodes_1D(6) =    0.136552932854927554864061855740E+00;
        lob_nodes_1D(7) =    0.399530940965348932264349791567E+00;
        lob_nodes_1D(8) =    0.632876153031869677662404854444E+00;
        lob_nodes_1D(9) =   0.819279321644006678348641581717E+00;
        lob_nodes_1D(10) =   0.944899272222882223407580138303E+00;
        lob_nodes_1D(11) =   1.0E+00;
    }

    else if (num == 13){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.953309846642163911896905464755E+00;
        lob_nodes_1D(2) =  - 0.846347564651872316865925607099E+00;
        lob_nodes_1D(3) =  - 0.686188469081757426072759039566E+00;
        lob_nodes_1D(4) =  - 0.482909821091336201746937233637E+00;
        lob_nodes_1D(5) =  - 0.249286930106239992568673700374E+00;
        lob_nodes_1D(6) =    0.0E+00;
        lob_nodes_1D(7) =    0.249286930106239992568673700374E+00;
        lob_nodes_1D(8) =    0.482909821091336201746937233637E+00;
        lob_nodes_1D(9) =   0.686188469081757426072759039566E+00;
        lob_nodes_1D(10) =   0.846347564651872316865925607099E+00;
        lob_nodes_1D(11) =   0.953309846642163911896905464755E+00;
        lob_nodes_1D(12) =   1.0E+00;
    }

    else if (num == 14){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.959935045267260901355100162015E+00;
        lob_nodes_1D(2) =  - 0.867801053830347251000220202908E+00;
        lob_nodes_1D(3) =  - 0.728868599091326140584672400521E+00;
        lob_nodes_1D(4) =  - 0.550639402928647055316622705859E+00;
        lob_nodes_1D(5) =  - 0.342724013342712845043903403642E+00;
        lob_nodes_1D(6) =  - 0.116331868883703867658776709736E+00;
        lob_nodes_1D(7) =    0.116331868883703867658776709736E+00;
        lob_nodes_1D(8) =    0.342724013342712845043903403642E+00;
        lob_nodes_1D(9) =   0.550639402928647055316622705859E+00;
        lob_nodes_1D(10) =   0.728868599091326140584672400521E+00;
        lob_nodes_1D(11) =   0.867801053830347251000220202908E+00;
        lob_nodes_1D(12) =   0.959935045267260901355100162015E+00;
        lob_nodes_1D(13) =   1.0E+00;
    }

    else if (num == 15){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.965245926503838572795851392070E+00;
        lob_nodes_1D(2) =  - 0.885082044222976298825401631482E+00;
        lob_nodes_1D(3) =  - 0.763519689951815200704118475976E+00;
        lob_nodes_1D(4) =  - 0.606253205469845711123529938637E+00;
        lob_nodes_1D(5) =  - 0.420638054713672480921896938739E+00;
        lob_nodes_1D(6) =  - 0.215353955363794238225679446273E+00;
        lob_nodes_1D(7) =    0.0E+00;
        lob_nodes_1D(8) =    0.215353955363794238225679446273E+00;
        lob_nodes_1D(9) =   0.420638054713672480921896938739E+00;
        lob_nodes_1D(10) =   0.606253205469845711123529938637E+00;
        lob_nodes_1D(11) =   0.763519689951815200704118475976E+00;
        lob_nodes_1D(12) =   0.885082044222976298825401631482E+00;
        lob_nodes_1D(13) =   0.965245926503838572795851392070E+00;
        lob_nodes_1D(14) =   1.0E+00;
    }

    else if (num == 16){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.969568046270217932952242738367E+00;
        lob_nodes_1D(2) =  - 0.899200533093472092994628261520E+00;
        lob_nodes_1D(3) =  - 0.792008291861815063931088270963E+00;
        lob_nodes_1D(4) =  - 0.652388702882493089467883219641E+00;
        lob_nodes_1D(5) =  - 0.486059421887137611781890785847E+00;
        lob_nodes_1D(6) =  - 0.299830468900763208098353454722E+00;
        lob_nodes_1D(7) =  - 0.101326273521949447843033005046E+00;
        lob_nodes_1D(8) =    0.101326273521949447843033005046E+00;
        lob_nodes_1D(9) =   0.299830468900763208098353454722E+00;
        lob_nodes_1D(10) =   0.486059421887137611781890785847E+00;
        lob_nodes_1D(11) =   0.652388702882493089467883219641E+00;
        lob_nodes_1D(12) =   0.792008291861815063931088270963E+00;
        lob_nodes_1D(13) =   0.899200533093472092994628261520E+00;
        lob_nodes_1D(14) =   0.969568046270217932952242738367E+00;
        lob_nodes_1D(15) =   1.0E+00;
    }

    else if (num == 17){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.973132176631418314156979501874E+00;
        lob_nodes_1D(2) =  - 0.910879995915573595623802506398E+00;
        lob_nodes_1D(3) =  - 0.815696251221770307106750553238E+00;
        lob_nodes_1D(4) =  - 0.691028980627684705394919357372E+00;
        lob_nodes_1D(5) =  - 0.541385399330101539123733407504E+00;
        lob_nodes_1D(6) =  - 0.372174433565477041907234680735E+00;
        lob_nodes_1D(7) =  - 0.189511973518317388304263014753E+00;
        lob_nodes_1D(8) =    0.0E+00;
        lob_nodes_1D(9) =    0.189511973518317388304263014753E+00;
        lob_nodes_1D(10) =   0.372174433565477041907234680735E+00;
        lob_nodes_1D(11) =   0.541385399330101539123733407504E+00;
        lob_nodes_1D(12) =   0.691028980627684705394919357372E+00;
        lob_nodes_1D(13) =   0.815696251221770307106750553238E+00;
        lob_nodes_1D(14) =   0.910879995915573595623802506398E+00;
        lob_nodes_1D(15) =   0.973132176631418314156979501874E+00;
        lob_nodes_1D(16) =   1.0E+00;
    }

    else if (num == 18){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.976105557412198542864518924342E+00;
        lob_nodes_1D(2) =  - 0.920649185347533873837854625431E+00;
        lob_nodes_1D(3) =  - 0.835593535218090213713646362328E+00;
        lob_nodes_1D(4) =  - 0.723679329283242681306210365302E+00;
        lob_nodes_1D(5) =  - 0.588504834318661761173535893194E+00;
        lob_nodes_1D(6) =  - 0.434415036912123975342287136741E+00;
        lob_nodes_1D(7) =  - 0.266362652878280984167665332026E+00;
        lob_nodes_1D(8) =  - 0.897490934846521110226450100886E-01;
        lob_nodes_1D(9) =    0.897490934846521110226450100886E-01;
        lob_nodes_1D(10) =   0.266362652878280984167665332026E+00;
        lob_nodes_1D(11) =   0.434415036912123975342287136741E+00;
        lob_nodes_1D(12) =   0.588504834318661761173535893194E+00;
        lob_nodes_1D(13) =   0.723679329283242681306210365302E+00;
        lob_nodes_1D(14) =   0.835593535218090213713646362328E+00;
        lob_nodes_1D(15) =   0.920649185347533873837854625431E+00;
        lob_nodes_1D(16) =   0.976105557412198542864518924342E+00;
        lob_nodes_1D(17) =   1.0E+00;
    }

    else if (num == 19) {
        lob_nodes_1D(0)=   - 1.0E+00;
        lob_nodes_1D(1)=   - 0.978611766222080095152634063110E+00;
        lob_nodes_1D(2)=   - 0.928901528152586243717940258797E+00;
        lob_nodes_1D(3)=   - 0.852460577796646093085955970041E+00;
        lob_nodes_1D(4)=   - 0.751494202552613014163637489634E+00;
        lob_nodes_1D(5)=   - 0.628908137265220497766832306229E+00;
        lob_nodes_1D(6)=   - 0.488229285680713502777909637625E+00;
        lob_nodes_1D(7)=   - 0.333504847824498610298500103845E+00;
        lob_nodes_1D(8)=   - 0.169186023409281571375154153445E+00;
        lob_nodes_1D(9)=     0.0E+00;
        lob_nodes_1D(10) =   0.169186023409281571375154153445E+00;
        lob_nodes_1D(11) =   0.333504847824498610298500103845E+00;
        lob_nodes_1D(12) =   0.488229285680713502777909637625E+00;
        lob_nodes_1D(13) =   0.628908137265220497766832306229E+00;
        lob_nodes_1D(14) =   0.751494202552613014163637489634E+00;
        lob_nodes_1D(15) =   0.852460577796646093085955970041E+00;
        lob_nodes_1D(16) =   0.928901528152586243717940258797E+00;
        lob_nodes_1D(17) =   0.978611766222080095152634063110E+00;
        lob_nodes_1D(18) =   1.0E+00;

    } // end if

    else if (num == 20){
        lob_nodes_1D(0) =  - 1.0E+00;
        lob_nodes_1D(1) =  - 0.980743704893914171925446438584E+00;
        lob_nodes_1D(2) =  - 0.935934498812665435716181584931E+00;
        lob_nodes_1D(3) =  - 0.866877978089950141309847214616E+00;
        lob_nodes_1D(4) =  - 0.775368260952055870414317527595E+00;
        lob_nodes_1D(5) =  - 0.663776402290311289846403322971E+00;
        lob_nodes_1D(6) =  - 0.534992864031886261648135961829E+00;
        lob_nodes_1D(7) =  - 0.392353183713909299386474703816E+00;
        lob_nodes_1D(8) =  - 0.239551705922986495182401356927E+00;
        lob_nodes_1D(9) =  - 0.805459372388218379759445181596E-01;
        lob_nodes_1D(10) =   0.805459372388218379759445181596E-01;
        lob_nodes_1D(11) =   0.239551705922986495182401356927E+00;
        lob_nodes_1D(12) =   0.392353183713909299386474703816E+00;
        lob_nodes_1D(13) =   0.534992864031886261648135961829E+00;
        lob_nodes_1D(14) =   0.663776402290311289846403322971E+00;
        lob_nodes_1D(15) =   0.775368260952055870414317527595E+00;
        lob_nodes_1D(16) =   0.866877978089950141309847214616E+00;
        lob_nodes_1D(17) =   0.935934498812665435716181584931E+00;
        lob_nodes_1D(18) =   0.980743704893914171925446438584E+00;
        lob_nodes_1D(19) =   1.0E+00;
    }
} // end of lobbato_nodes_1D function


/**************************************************************************************//**
*  lobatto_weights_1D creates quadrature weights corresponding the nodal positions defined 
*  on [-1,1] using the Gauss-Lobatto quadrature points. The CArray lob_weights_1D is passed 
*  in my reference and modified in place. The integer num is the numer of points being 
*  defined in 1D.
*****************************************************************************************/

void lobatto_weights_1D(
                        CArray <real_t> &lob_weights_1D,  // Lobbatto weights
                        const int &num){                     // Interpolation order
    if (num == 1){
        lob_weights_1D(0) = 2.0;
    }
    else if (num == 2){
        lob_weights_1D(0) = 1.0;
        lob_weights_1D(1) = 1.0;
    }
    else if (num == 3){
        lob_weights_1D(0) = 1.0/3.0;
        lob_weights_1D(1) = 4.0/3.0;
        lob_weights_1D(2) = 1.0/3.0;
    }
    else if (num == 4){
        lob_weights_1D(0) = 1.0/6.0;
        lob_weights_1D(1) = 5.0/6.0;
        lob_weights_1D(2) = 5.0/6.0;
        lob_weights_1D(3) = 1.0/6.0;
    }
    else if (num == 5){
        lob_weights_1D(0) = 1.0/10.0;
        lob_weights_1D(1) = 49.0/90.0;
        lob_weights_1D(2) = 32.0/45.0;
        lob_weights_1D(3) = 49.0/90.0;
        lob_weights_1D(4) = 1.0/10.0;
    }
    else if (num == 6){
        lob_weights_1D(0) = 1.0/15.0;
        lob_weights_1D(1) = 1.0/30.0*(14.0 - sqrt(7.0));
        lob_weights_1D(2) = 1.0/30.0*(14.0 + sqrt(7.0));
        lob_weights_1D(3) = 1.0/30.0*(14.0 + sqrt(7.0));
        lob_weights_1D(4) = 1.0/30.0*(14.0 - sqrt(7.0));
        lob_weights_1D(5) = 1.0/15.0;
    }
    else if (num == 7){
        lob_weights_1D(0) =  0.476190476190476190476190476190E-01;
        lob_weights_1D(1) =  0.276826047361565948010700406290E+00;
        lob_weights_1D(2) =  0.431745381209862623417871022281E+00;
        lob_weights_1D(3) =  0.487619047619047619047619047619E+00;
        lob_weights_1D(4) =  0.431745381209862623417871022281E+00;
        lob_weights_1D(5) =  0.276826047361565948010700406290E+00;
        lob_weights_1D(6) =  0.476190476190476190476190476190E-01;
    }
    else if (num == 8){
        lob_weights_1D(0) =  0.357142857142857142857142857143E-01;
        lob_weights_1D(1) =  0.210704227143506039382991065776E+00;
        lob_weights_1D(2) =  0.341122692483504364764240677108E+00;
        lob_weights_1D(3) =  0.412458794658703881567052971402E+00;
        lob_weights_1D(4) =  0.412458794658703881567052971402E+00;
        lob_weights_1D(5) =  0.341122692483504364764240677108E+00;
        lob_weights_1D(6) =  0.210704227143506039382991065776E+00;
        lob_weights_1D(7) =  0.357142857142857142857142857143E-01;
    }
    else if (num == 9){
        lob_weights_1D(0) =  0.277777777777777777777777777778E-01;
        lob_weights_1D(1) =  0.165495361560805525046339720029E+00;
        lob_weights_1D(2) =  0.274538712500161735280705618579E+00;
        lob_weights_1D(3) =  0.346428510973046345115131532140E+00;
        lob_weights_1D(4) =  0.371519274376417233560090702948E+00;
        lob_weights_1D(5) =  0.346428510973046345115131532140E+00;
        lob_weights_1D(6) =  0.274538712500161735280705618579E+00;
        lob_weights_1D(7) =  0.165495361560805525046339720029E+00;
        lob_weights_1D(8) =  0.277777777777777777777777777778E-01;
    }
    else if (num == 10){
        lob_weights_1D(0) =  0.222222222222222222222222222222E-01;
        lob_weights_1D(1) =  0.133305990851070111126227170755E+00;
        lob_weights_1D(2) =  0.224889342063126452119457821731E+00;
        lob_weights_1D(3) =  0.292042683679683757875582257374E+00;
        lob_weights_1D(4) =  0.327539761183897456656510527917E+00;
        lob_weights_1D(5) =  0.327539761183897456656510527917E+00;
        lob_weights_1D(6) =  0.292042683679683757875582257374E+00;
        lob_weights_1D(7) =  0.224889342063126452119457821731E+00;
        lob_weights_1D(8) =  0.133305990851070111126227170755E+00;
        lob_weights_1D(9) =  0.222222222222222222222222222222E-01;
    }
    else if (num == 11){
        lob_weights_1D(0) =  0.181818181818181818181818181818E-01;
        lob_weights_1D(1) =  0.109612273266994864461403449580E+00;
        lob_weights_1D(2) =  0.187169881780305204108141521899E+00;
        lob_weights_1D(3) =  0.248048104264028314040084866422E+00;
        lob_weights_1D(4) =  0.286879124779008088679222403332E+00;
        lob_weights_1D(5) =  0.300217595455690693785931881170E+00;
        lob_weights_1D(6) =  0.286879124779008088679222403332E+00;
        lob_weights_1D(7) =  0.248048104264028314040084866422E+00;
        lob_weights_1D(8) =  0.187169881780305204108141521899E+00;
        lob_weights_1D(9) =  0.109612273266994864461403449580E+00;
        lob_weights_1D(10)=  0.181818181818181818181818181818E-01;
    }

    else if (num == 12){
        lob_weights_1D(0) =  0.151515151515151515151515151515E-01;
        lob_weights_1D(1) =  0.916845174131961306683425941341E-01;
        lob_weights_1D(2) =  0.157974705564370115164671062700E+00;
        lob_weights_1D(3) =  0.212508417761021145358302077367E+00;
        lob_weights_1D(4) =  0.251275603199201280293244412148E+00;
        lob_weights_1D(5) =  0.271405240910696177000288338500E+00;
        lob_weights_1D(6) =  0.271405240910696177000288338500E+00;
        lob_weights_1D(7) =  0.251275603199201280293244412148E+00;
        lob_weights_1D(8) =  0.212508417761021145358302077367E+00;
        lob_weights_1D(9) =  0.157974705564370115164671062700E+00;
        lob_weights_1D(10) = 0.916845174131961306683425941341E-01;
        lob_weights_1D(11) = 0.151515151515151515151515151515E-01;
    }

    else if (num == 13){
        lob_weights_1D(0) =  0.128205128205128205128205128205E-01;
        lob_weights_1D(1) =  0.778016867468189277935889883331E-01;
        lob_weights_1D(2) =  0.134981926689608349119914762589E+00;
        lob_weights_1D(3) =  0.183646865203550092007494258747E+00;
        lob_weights_1D(4) =  0.220767793566110086085534008379E+00;
        lob_weights_1D(5) =  0.244015790306676356458578148360E+00;
        lob_weights_1D(6) =  0.251930849333446736044138641541E+00;
        lob_weights_1D(7) =  0.244015790306676356458578148360E+00;
        lob_weights_1D(8) =  0.220767793566110086085534008379E+00;
        lob_weights_1D(9) =  0.183646865203550092007494258747E+00;
        lob_weights_1D(10) = 0.134981926689608349119914762589E+00;
        lob_weights_1D(11) = 0.778016867468189277935889883331E-01;
        lob_weights_1D(12) = 0.128205128205128205128205128205E-01;
    }

    else if (num == 14){
        lob_weights_1D(0) =  0.109890109890109890109890109890E-01;
        lob_weights_1D(1) =  0.668372844976812846340706607461E-01;
        lob_weights_1D(2) =  0.116586655898711651540996670655E+00;
        lob_weights_1D(3) =  0.160021851762952142412820997988E+00;
        lob_weights_1D(4) =  0.194826149373416118640331778376E+00;
        lob_weights_1D(5) =  0.219126253009770754871162523954E+00;
        lob_weights_1D(6) =  0.231612794468457058889628357293E+00;
        lob_weights_1D(7) =  0.231612794468457058889628357293E+00;
        lob_weights_1D(8) =  0.219126253009770754871162523954E+00;
        lob_weights_1D(9) =  0.194826149373416118640331778376E+00;
        lob_weights_1D(10) = 0.160021851762952142412820997988E+00;
        lob_weights_1D(11) = 0.116586655898711651540996670655E+00;
        lob_weights_1D(12) = 0.668372844976812846340706607461E-01;
        lob_weights_1D(13) = 0.109890109890109890109890109890E-01;
    }


    else if (num == 15){
        lob_weights_1D(0) =  0.952380952380952380952380952381E-02;
        lob_weights_1D(1) =  0.580298930286012490968805840253E-01;
        lob_weights_1D(2) =  0.101660070325718067603666170789E+00;
        lob_weights_1D(3) =  0.140511699802428109460446805644E+00;
        lob_weights_1D(4) =  0.172789647253600949052077099408E+00;
        lob_weights_1D(5) =  0.196987235964613356092500346507E+00;
        lob_weights_1D(6) =  0.211973585926820920127430076977E+00;
        lob_weights_1D(7) =  0.217048116348815649514950214251E+00;
        lob_weights_1D(8) =  0.211973585926820920127430076977E+00;
        lob_weights_1D(9) =  0.196987235964613356092500346507E+00;
        lob_weights_1D(10) = 0.172789647253600949052077099408E+00;
        lob_weights_1D(11) = 0.140511699802428109460446805644E+00;
        lob_weights_1D(12) = 0.101660070325718067603666170789E+00;
        lob_weights_1D(13) = 0.580298930286012490968805840253E-01;
        lob_weights_1D(14) = 0.952380952380952380952380952381E-02;
    }


    else if (num == 16){
        lob_weights_1D(0) =  0.833333333333333333333333333333E-02;
        lob_weights_1D(1) =  0.508503610059199054032449195655E-01;
        lob_weights_1D(2) =  0.893936973259308009910520801661E-01;
        lob_weights_1D(3) =  0.124255382132514098349536332657E+00;
        lob_weights_1D(4) =  0.154026980807164280815644940485E+00;
        lob_weights_1D(5) =  0.177491913391704125301075669528E+00;
        lob_weights_1D(6) =  0.193690023825203584316913598854E+00;
        lob_weights_1D(7) =  0.201958308178229871489199125411E+00;
        lob_weights_1D(8) =  0.201958308178229871489199125411E+00;
        lob_weights_1D(9) =  0.193690023825203584316913598854E+00;
        lob_weights_1D(10) = 0.177491913391704125301075669528E+00;
        lob_weights_1D(11) = 0.154026980807164280815644940485E+00;
        lob_weights_1D(12) = 0.124255382132514098349536332657E+00;
        lob_weights_1D(13) = 0.893936973259308009910520801661E-01;
        lob_weights_1D(14) = 0.508503610059199054032449195655E-01;
        lob_weights_1D(15) = 0.833333333333333333333333333333E-02;
    }


    else if (num == 17){
        lob_weights_1D(0) =  0.735294117647058823529411764706E-02;
        lob_weights_1D(1) =  0.449219405432542096474009546232E-01;
        lob_weights_1D(2) =  0.791982705036871191902644299528E-01;
        lob_weights_1D(3) =  0.110592909007028161375772705220E+00;
        lob_weights_1D(4) =  0.137987746201926559056201574954E+00;
        lob_weights_1D(5) =  0.160394661997621539516328365865E+00;
        lob_weights_1D(6) =  0.177004253515657870436945745363E+00;
        lob_weights_1D(7) =  0.187216339677619235892088482861E+00;
        lob_weights_1D(8) =  0.190661874753469433299407247028E+00;
        lob_weights_1D(9) =  0.187216339677619235892088482861E+00;
        lob_weights_1D(10) = 0.177004253515657870436945745363E+00;
        lob_weights_1D(11) = 0.160394661997621539516328365865E+00;
        lob_weights_1D(12) = 0.137987746201926559056201574954E+00;
        lob_weights_1D(13) = 0.110592909007028161375772705220E+00;
        lob_weights_1D(14) = 0.791982705036871191902644299528E-01;
        lob_weights_1D(15) = 0.449219405432542096474009546232E-01;
        lob_weights_1D(16) = 0.735294117647058823529411764706E-02;
    }

    else if (num == 18){
        lob_weights_1D(0) =  0.653594771241830065359477124183E-02;
        lob_weights_1D(1) =  0.399706288109140661375991764101E-01;
        lob_weights_1D(2) =  0.706371668856336649992229601678E-01;
        lob_weights_1D(3) =  0.990162717175028023944236053187E-01;
        lob_weights_1D(4) =  0.124210533132967100263396358897E+00;
        lob_weights_1D(5) =  0.145411961573802267983003210494E+00;
        lob_weights_1D(6) =  0.161939517237602489264326706700E+00;
        lob_weights_1D(7) =  0.173262109489456226010614403827E+00;
        lob_weights_1D(8) =  0.179015863439703082293818806944E+00;
        lob_weights_1D(9) =  0.179015863439703082293818806944E+00;
        lob_weights_1D(10) = 0.173262109489456226010614403827E+00;
        lob_weights_1D(11) = 0.161939517237602489264326706700E+00;
        lob_weights_1D(12) = 0.145411961573802267983003210494E+00;
        lob_weights_1D(13) = 0.124210533132967100263396358897E+00;
        lob_weights_1D(14) = 0.990162717175028023944236053187E-01;
        lob_weights_1D(15) = 0.706371668856336649992229601678E-01;
        lob_weights_1D(16) = 0.399706288109140661375991764101E-01;
        lob_weights_1D(17) = 0.653594771241830065359477124183E-02;
    }

    else if (num == 19) {
        lob_weights_1D(0) =  0.584795321637426900584795321637E-02;
        lob_weights_1D(1) =  0.357933651861764771154255690351E-01;
        lob_weights_1D(2) =  0.633818917626297368516956904183E-01;
        lob_weights_1D(3) =  0.891317570992070844480087905562E-01;
        lob_weights_1D(4) =  0.112315341477305044070910015464E+00;
        lob_weights_1D(5) =  0.132267280448750776926046733910E+00;
        lob_weights_1D(6) =  0.148413942595938885009680643668E+00;
        lob_weights_1D(7) =  0.160290924044061241979910968184E+00;
        lob_weights_1D(8) =  0.167556584527142867270137277740E+00;
        lob_weights_1D(9) =  0.170001919284827234644672715617E+00;
        lob_weights_1D(10) = 0.167556584527142867270137277740E+00;
        lob_weights_1D(11) = 0.160290924044061241979910968184E+00;
        lob_weights_1D(12) = 0.148413942595938885009680643668E+00;
        lob_weights_1D(13) = 0.132267280448750776926046733910E+00;
        lob_weights_1D(14) = 0.112315341477305044070910015464E+00;
        lob_weights_1D(15) = 0.891317570992070844480087905562E-01;
        lob_weights_1D(16) = 0.633818917626297368516956904183E-01;
        lob_weights_1D(17) = 0.357933651861764771154255690351E-01;
        lob_weights_1D(18) = 0.584795321637426900584795321637E-02;
    } // end if

    else if (num == 20) {
        lob_weights_1D(0) =  0.526315789473684210526315789474E-02;
        lob_weights_1D(1) =  0.322371231884889414916050281173E-01;
        lob_weights_1D(2) =  0.571818021275668260047536271732E-01;
        lob_weights_1D(3) =  0.806317639961196031447768461137E-01;
        lob_weights_1D(4) =  0.101991499699450815683781205733E+00;
        lob_weights_1D(5) =  0.120709227628674725099429705002E+00;
        lob_weights_1D(6) =  0.136300482358724184489780792989E+00;
        lob_weights_1D(7) =  0.148361554070916825814713013734E+00;
        lob_weights_1D(8) =  0.156580102647475487158169896794E+00;
        lob_weights_1D(9) =  0.160743286387845749007726726449E+00;
        lob_weights_1D(10) = 0.160743286387845749007726726449E+00;
        lob_weights_1D(11) = 0.156580102647475487158169896794E+00;
        lob_weights_1D(12) = 0.148361554070916825814713013734E+00;
        lob_weights_1D(13) = 0.136300482358724184489780792989E+00;
        lob_weights_1D(14) = 0.120709227628674725099429705002E+00;
        lob_weights_1D(15) = 0.101991499699450815683781205733E+00;
        lob_weights_1D(16) = 0.806317639961196031447768461137E-01;
        lob_weights_1D(17) = 0.571818021275668260047536271732E-01;
        lob_weights_1D(18) = 0.322371231884889414916050281173E-01;
        lob_weights_1D(19) = 0.526315789473684210526315789474E-02;
    } // end if
} // end of lobatto_weights_1D function

void legendre_nodes_1D(
                       CArray <real_t> &leg_nodes_1D,
                       const int &num){

    if (num == 1){
        leg_nodes_1D(0) = 0.0;
    }
    else if (num == 2){
        leg_nodes_1D(0) = -0.577350269189625764509148780501;
        leg_nodes_1D(1) =  0.577350269189625764509148780501;
    }
    else if (num == 3){
        leg_nodes_1D(0) = -0.774596669241483377035853079956;
        leg_nodes_1D(1) =  0.0;
        leg_nodes_1D(2) =  0.774596669241483377035853079956;
    }
    else if (num == 4){
        leg_nodes_1D(0) = -0.861136311594052575223946488892;
        leg_nodes_1D(1) = -0.339981043584856264802665759103;
        leg_nodes_1D(2) =  0.339981043584856264802665759103;
        leg_nodes_1D(3) =  0.861136311594052575223946488892;
    }
    else if (num == 5){
        leg_nodes_1D(0) = -0.906179845938663992797626878299;
        leg_nodes_1D(1) = -0.538469310105683091036314420700;
        leg_nodes_1D(2) =  0.0;
        leg_nodes_1D(3) =  0.538469310105683091036314420700;
        leg_nodes_1D(4) =  0.906179845938663992797626878299;
    }
    else if (num == 6){
        leg_nodes_1D(0) = -0.932469514203152027812301554493;
        leg_nodes_1D(1) = -0.661209386466264513661399595019;
        leg_nodes_1D(2) = -0.238619186083196908630501721680;
        leg_nodes_1D(3) =  0.238619186083196908630501721680;
        leg_nodes_1D(4) =  0.661209386466264513661399595019;
        leg_nodes_1D(5) =  0.932469514203152027812301554493;
    }
    else if (num == 7){
        leg_nodes_1D(0) = -0.949107912342758524526189684047;
        leg_nodes_1D(1) = -0.741531185599394439863864773280;
        leg_nodes_1D(2) = -0.405845151377397166906606412076;
        leg_nodes_1D(3) =  0.0E+00;
        leg_nodes_1D(4) =  0.405845151377397166906606412076;
        leg_nodes_1D(5) =  0.741531185599394439863864773280;
        leg_nodes_1D(6) =  0.949107912342758524526189684047;
    }
    else if (num == 8){
        leg_nodes_1D(0) = -0.960289856497536231683560868569;
        leg_nodes_1D(1) = -0.796666477413626739591553936475;
        leg_nodes_1D(2) = -0.525532409916328985817739049189;
        leg_nodes_1D(3) = -0.183434642495649804939476142360;
        leg_nodes_1D(4) =  0.183434642495649804939476142360;
        leg_nodes_1D(5) =  0.525532409916328985817739049189;
        leg_nodes_1D(6) =  0.796666477413626739591553936475;
        leg_nodes_1D(7) =  0.960289856497536231683560868569;
    }
    else if (num == 9){
        leg_nodes_1D(0) = -0.968160239507626089835576202903;
        leg_nodes_1D(1) = -0.836031107326635794299429788069;
        leg_nodes_1D(2) = -0.613371432700590397308702039341;
        leg_nodes_1D(3) = -0.324253423403808929038538014643;
        leg_nodes_1D(4) =  0.0E+00;
        leg_nodes_1D(5) =  0.324253423403808929038538014643;
        leg_nodes_1D(6) =  0.613371432700590397308702039341;
        leg_nodes_1D(7) =  0.836031107326635794299429788069;
        leg_nodes_1D(8) =  0.968160239507626089835576202903;
    }
    else if (num == 10){
        leg_nodes_1D(0) = -0.9739065285171717200779640120844;
        leg_nodes_1D(1) = -0.8650633666889845107320966884234;
        leg_nodes_1D(2) = -0.6794095682990244062343273651148;
        leg_nodes_1D(3) = -0.4333953941292471907992659431657;
        leg_nodes_1D(4) = -0.1488743389816312108848260011297;
        leg_nodes_1D(5) =  0.1488743389816312108848260011297;
        leg_nodes_1D(6) =  0.4333953941292471907992659431657;
        leg_nodes_1D(7) =  0.6794095682990244062343273651148;
        leg_nodes_1D(8) =  0.8650633666889845107320966884234;
        leg_nodes_1D(9) =  0.9739065285171717200779640120844;
        
    }
    else if (num == 11){
        leg_nodes_1D(0) = -0.9782286581460569928039380011228;
        leg_nodes_1D(1) = -0.8870625997680952990751577693039;
        leg_nodes_1D(2) = -0.7301520055740493240934162520311;
        leg_nodes_1D(3) = -0.5190961292068118159257256694586;
        leg_nodes_1D(4) = -0.2695431559523449723315319854008;
        leg_nodes_1D(5) =  0.0E+00;
        leg_nodes_1D(6) =  0.2695431559523449723315319854008;
        leg_nodes_1D(7) =  0.5190961292068118159257256694586;
        leg_nodes_1D(8) =  0.7301520055740493240934162520311;
        leg_nodes_1D(9) =  0.8870625997680952990751577693039;
        leg_nodes_1D(10) = 0.9782286581460569928039380011228;
    }
    
    else if (num == 12){
        leg_nodes_1D(0) = -0.9815606342467192506905490901492;
        leg_nodes_1D(1) = -0.9041172563704748566784658661190;
        leg_nodes_1D(2) = -0.7699026741943046870368938332128;
        leg_nodes_1D(3) = -0.5873179542866174472967024189405;
        leg_nodes_1D(4) = -0.3678314989981801937526915366437;
        leg_nodes_1D(5) = -0.1252334085114689154724413694638;
        leg_nodes_1D(6) =  0.1252334085114689154724413694638;
        leg_nodes_1D(7) =  0.3678314989981801937526915366437;
        leg_nodes_1D(8) =  0.5873179542866174472967024189405;
        leg_nodes_1D(9) =  0.7699026741943046870368938332128;
        leg_nodes_1D(10) = 0.9041172563704748566784658661190;
        leg_nodes_1D(11) = 0.9815606342467192506905490901492;
    }
    
    else if (num == 13){
        leg_nodes_1D(0) = -0.98418305471858814947282944880710;
        leg_nodes_1D(1) = -0.91759839922297796520654783650071;
        leg_nodes_1D(2) = -0.80157809073330991279420648958285;
        leg_nodes_1D(3) = -0.64234933944034022064398460699551;
        leg_nodes_1D(4) = -0.44849275103644685287791285212763;
        leg_nodes_1D(5) = -0.23045831595513479406552812109798;
        leg_nodes_1D(6) =  0.0E+00;
        leg_nodes_1D(7) =  0.23045831595513479406552812109798;
        leg_nodes_1D(8) =  0.44849275103644685287791285212763;
        leg_nodes_1D(9) =  0.64234933944034022064398460699551;
        leg_nodes_1D(10) = 0.80157809073330991279420648958285;
        leg_nodes_1D(11) = 0.91759839922297796520654783650071;
        leg_nodes_1D(12) = 0.98418305471858814947282944880710;
    }
    
    else if (num == 14){
        leg_nodes_1D(0) = -0.986283808696812338841597266704052;
        leg_nodes_1D(1) = -0.928434883663573517336391139377874;
        leg_nodes_1D(2) = -0.827201315069764993189794742650394;
        leg_nodes_1D(3) = -0.687292904811685470148019803019334;
        leg_nodes_1D(4) = -0.515248636358154091965290718551188;
        leg_nodes_1D(5) = -0.319112368927889760435671824168475;
        leg_nodes_1D(6) = -0.108054948707343662066244650219834;
        leg_nodes_1D(7) =  0.108054948707343662066244650219834;
        leg_nodes_1D(8) =  0.319112368927889760435671824168475;
        leg_nodes_1D(9) =  0.515248636358154091965290718551188;
        leg_nodes_1D(10) = 0.687292904811685470148019803019334;
        leg_nodes_1D(11) = 0.827201315069764993189794742650394;
        leg_nodes_1D(12) = 0.928434883663573517336391139377874;
        leg_nodes_1D(13) = 0.986283808696812338841597266704052;
    }
    
    else if (num == 15){
        leg_nodes_1D(0) = -0.987992518020485428489565718586612;
        leg_nodes_1D(1) = -0.937273392400705904307758947710209;
        leg_nodes_1D(2) = -0.848206583410427216200648320774216;
        leg_nodes_1D(3) = -0.724417731360170047416186054613938;
        leg_nodes_1D(4) = -0.570972172608538847537226737253910;
        leg_nodes_1D(5) = -0.394151347077563369897207370981045;
        leg_nodes_1D(6) = -0.201194093997434522300628303394596;
        leg_nodes_1D(7) =  0.0E+00;
        leg_nodes_1D(8) =  0.201194093997434522300628303394596;
        leg_nodes_1D(9) =  0.394151347077563369897207370981045;
        leg_nodes_1D(10) = 0.570972172608538847537226737253910;
        leg_nodes_1D(11) = 0.724417731360170047416186054613938;
        leg_nodes_1D(12) = 0.848206583410427216200648320774216;
        leg_nodes_1D(13) = 0.937273392400705904307758947710209;
        leg_nodes_1D(14) = 0.987992518020485428489565718586612;
    }
    
    else if (num == 16){
        leg_nodes_1D(0) = -0.989400934991649932596154173450332;
        leg_nodes_1D(1) = -0.944575023073232576077988415534608;
        leg_nodes_1D(2) = -0.865631202387831743880467897712393;
        leg_nodes_1D(3) = -0.755404408355003033895101194847442;
        leg_nodes_1D(4) = -0.617876244402643748446671764048791;
        leg_nodes_1D(5) = -0.458016777657227386342419442983577;
        leg_nodes_1D(6) = -0.281603550779258913230460501460496;
        leg_nodes_1D(7) = -0.095012509837637440185319335424958;
        leg_nodes_1D(8) =  0.095012509837637440185319335424958;
        leg_nodes_1D(9) =  0.281603550779258913230460501460496;
        leg_nodes_1D(10) = 0.458016777657227386342419442983577;
        leg_nodes_1D(11) = 0.617876244402643748446671764048791;
        leg_nodes_1D(12) = 0.755404408355003033895101194847442;
        leg_nodes_1D(13) = 0.865631202387831743880467897712393;
        leg_nodes_1D(14) = 0.944575023073232576077988415534608;
        leg_nodes_1D(15) = 0.989400934991649932596154173450332;
    }
    
    else if (num == 17){
        leg_nodes_1D(0) = -0.990575475314417335675434019940665;
        leg_nodes_1D(1) = -0.950675521768767761222716957895803;
        leg_nodes_1D(2) = -0.880239153726985902122955694488155;
        leg_nodes_1D(3) = -0.781514003896801406925230055520476;
        leg_nodes_1D(4) = -0.657671159216690765850302216643002;
        leg_nodes_1D(5) = -0.512690537086476967886246568629551;
        leg_nodes_1D(6) = -0.351231763453876315297185517095346;
        leg_nodes_1D(7) = -0.178484181495847855850677493654065;
        leg_nodes_1D(8) =  0.0E+00;
        leg_nodes_1D(9) =  0.178484181495847855850677493654065;
        leg_nodes_1D(10) = 0.351231763453876315297185517095346;
        leg_nodes_1D(11) = 0.512690537086476967886246568629551;
        leg_nodes_1D(12) = 0.657671159216690765850302216643002;
        leg_nodes_1D(13) = 0.781514003896801406925230055520476;
        leg_nodes_1D(14) = 0.880239153726985902122955694488155;
        leg_nodes_1D(15) = 0.950675521768767761222716957895803;
        leg_nodes_1D(16) = 0.990575475314417335675434019940665;
    }
    
    else if (num == 18){
        leg_nodes_1D(0) = -0.991565168420930946730016004706150;
        leg_nodes_1D(1) = -0.955823949571397755181195892929776;
        leg_nodes_1D(2) = -0.892602466497555739206060591127145;
        leg_nodes_1D(3) = -0.803704958972523115682417455014590;
        leg_nodes_1D(4) = -0.691687043060353207874891081288848;
        leg_nodes_1D(5) = -0.559770831073947534607871548525329;
        leg_nodes_1D(6) = -0.411751161462842646035931793833051;
        leg_nodes_1D(7) = -0.251886225691505509588972854877911;
        leg_nodes_1D(8) = -0.084775013041735301242261852935783;
        leg_nodes_1D(9) =  0.084775013041735301242261852935783;
        leg_nodes_1D(10) = 0.251886225691505509588972854877911;
        leg_nodes_1D(11) = 0.411751161462842646035931793833051;
        leg_nodes_1D(12) = 0.559770831073947534607871548525329;
        leg_nodes_1D(13) = 0.691687043060353207874891081288848;
        leg_nodes_1D(14) = 0.803704958972523115682417455014590;
        leg_nodes_1D(15) = 0.892602466497555739206060591127145;
        leg_nodes_1D(16) = 0.955823949571397755181195892929776;
        leg_nodes_1D(17) = 0.991565168420930946730016004706150;
    }
    
    else if (num == 19) {
        leg_nodes_1D(0) = -0.992406843843584403189017670253260;
        leg_nodes_1D(1) = -0.960208152134830030852778840687651;
        leg_nodes_1D(2) = -0.903155903614817901642660928532312;
        leg_nodes_1D(3) = -0.822714656537142824978922486712713;
        leg_nodes_1D(4) = -0.720966177335229378617095860823781;
        leg_nodes_1D(5) = -0.600545304661681023469638164946239;
        leg_nodes_1D(6) = -0.464570741375960945717267148104102;
        leg_nodes_1D(7) = -0.316564099963629831990117328849844;
        leg_nodes_1D(8) = -0.160358645640225375868096115740743;
        leg_nodes_1D(9) =  0.0E+00;
        leg_nodes_1D(10) = 0.160358645640225375868096115740743;
        leg_nodes_1D(11) = 0.316564099963629831990117328849844;
        leg_nodes_1D(12) = 0.464570741375960945717267148104102;
        leg_nodes_1D(13) = 0.600545304661681023469638164946239;
        leg_nodes_1D(14) = 0.720966177335229378617095860823781;
        leg_nodes_1D(15) = 0.822714656537142824978922486712713;
        leg_nodes_1D(16) = 0.903155903614817901642660928532312;
        leg_nodes_1D(17) = 0.960208152134830030852778840687651;
        leg_nodes_1D(18) = 0.992406843843584403189017670253260;
        
    } // end if
    
    
}; // end of legendre_nodes_1D function


void legendre_weights_1D(
                         CArray <real_t> &leg_weights_1D,  // Legendre weights
                         const int &num){                  // Interpolation order
    if (num == 1){
        leg_weights_1D(0) = 2.0;
    }
    else if (num == 2){
        leg_weights_1D(0) = 1.0;
        leg_weights_1D(1) = 1.0;
    }
    else if (num == 3){
        leg_weights_1D(0) = 0.555555555555555555555555555555555;
        leg_weights_1D(1) = 0.888888888888888888888888888888888;
        leg_weights_1D(2) = 0.555555555555555555555555555555555;
    }
    else if (num == 4){
        leg_weights_1D(0) = 0.347854845137453857373063949221999;
        leg_weights_1D(1) = 0.652145154862546142626936050778000;
        leg_weights_1D(2) = 0.652145154862546142626936050778000;
        leg_weights_1D(3) = 0.347854845137453857373063949221999;
    }
    else if (num == 5){
        leg_weights_1D(0) = 0.236926885056189087514264040719917;
        leg_weights_1D(1) = 0.478628670499366468041291514835638;
        leg_weights_1D(2) = 0.568888888888888888888888888888888;
        leg_weights_1D(3) = 0.478628670499366468041291514835638;
        leg_weights_1D(4) = 0.236926885056189087514264040719917;
    }
    else if (num == 6){
        leg_weights_1D(0) = 0.171324492379170345040296142172732;
        leg_weights_1D(1) = 0.360761573048138607569833513837716;
        leg_weights_1D(2) = 0.467913934572691047389870343989550;
        leg_weights_1D(3) = 0.467913934572691047389870343989550;
        leg_weights_1D(4) = 0.360761573048138607569833513837716;
        leg_weights_1D(5) = 0.171324492379170345040296142172732;
    }
    else if (num == 7){
        leg_weights_1D(0) = 0.129484966168869693270611432679082;
        leg_weights_1D(1) = 0.279705391489276667901467771423779;
        leg_weights_1D(2) = 0.381830050505118944950369775488975;
        leg_weights_1D(3) = 0.417959183673469387755102040816326;
        leg_weights_1D(4) = 0.381830050505118944950369775488975;
        leg_weights_1D(5) = 0.279705391489276667901467771423779;
        leg_weights_1D(6) = 0.129484966168869693270611432679082;
    }
    else if (num == 8){
        leg_weights_1D(0) = 0.101228536290376259152531354309962;
        leg_weights_1D(1) = 0.222381034453374470544355994426240;
        leg_weights_1D(2) = 0.313706645877887287337962201986601;
        leg_weights_1D(3) = 0.362683783378361982965150449277195;
        leg_weights_1D(4) = 0.362683783378361982965150449277195;
        leg_weights_1D(5) = 0.313706645877887287337962201986601;
        leg_weights_1D(6) = 0.222381034453374470544355994426240;
        leg_weights_1D(7) = 0.101228536290376259152531354309962;
    }
    else if (num == 9){
        leg_weights_1D(0) = 0.081274388361574411971892158110523;
        leg_weights_1D(1) = 0.180648160694857404058472031242912;
        leg_weights_1D(2) = 0.260610696402935462318742869418632;
        leg_weights_1D(3) = 0.312347077040002840068630406584443;
        leg_weights_1D(4) = 0.330239355001259763164525069286974;
        leg_weights_1D(5) = 0.312347077040002840068630406584443;
        leg_weights_1D(6) = 0.260610696402935462318742869418632;
        leg_weights_1D(7) = 0.180648160694857404058472031242912;
        leg_weights_1D(8) = 0.081274388361574411971892158110523;
    }
    else if (num == 10){
        leg_weights_1D(0) = 0.066671344308688137593568809893331;
        leg_weights_1D(1) = 0.149451349150580593145776339657697;
        leg_weights_1D(2) = 0.219086362515982043995534934228163;
        leg_weights_1D(3) = 0.269266719309996355091226921569469;
        leg_weights_1D(4) = 0.295524224714752870173892994651338;
        leg_weights_1D(5) = 0.295524224714752870173892994651338;
        leg_weights_1D(6) = 0.269266719309996355091226921569469;
        leg_weights_1D(7) = 0.219086362515982043995534934228163;
        leg_weights_1D(8) = 0.149451349150580593145776339657697;
        leg_weights_1D(9) = 0.066671344308688137593568809893331;
    }
    else if (num == 11){
        leg_weights_1D(0) = 0.055668567116173666482753720442548;
        leg_weights_1D(1) = 0.125580369464904624634694299223940;
        leg_weights_1D(2) = 0.186290210927734251426097641431655;
        leg_weights_1D(3) = 0.233193764591990479918523704843175;
        leg_weights_1D(4) = 0.262804544510246662180688869890509;
        leg_weights_1D(5) = 0.272925086777900630714483528336342;
        leg_weights_1D(6) = 0.262804544510246662180688869890509;
        leg_weights_1D(7) = 0.233193764591990479918523704843175;
        leg_weights_1D(8) = 0.186290210927734251426097641431655;
        leg_weights_1D(9) = 0.125580369464904624634694299223940;
        leg_weights_1D(10)= 0.055668567116173666482753720442548;
    }
    
    else if (num == 12){
        leg_weights_1D(0) =  0.04717533638651182719461596148501;
        leg_weights_1D(1) =  0.10693932599531843096025471819399;
        leg_weights_1D(2) =  0.16007832854334622633465252954335;
        leg_weights_1D(3) =  0.20316742672306592174906445580979;
        leg_weights_1D(4) =  0.23349253653835480876084989892487;
        leg_weights_1D(5) =  0.24914704581340278500056243604295;
        leg_weights_1D(6) =  0.24914704581340278500056243604295;
        leg_weights_1D(7) =  0.23349253653835480876084989892487;
        leg_weights_1D(8) =  0.20316742672306592174906445580979;
        leg_weights_1D(9) =  0.16007832854334622633465252954335;
        leg_weights_1D(10) = 0.10693932599531843096025471819399;
        leg_weights_1D(11) = 0.04717533638651182719461596148501;
    }
    
    else if (num == 13){
        leg_weights_1D(0) =  0.04048400476531587952002159220098;
        leg_weights_1D(1) =  0.09212149983772844791442177595379;
        leg_weights_1D(2) =  0.13887351021978723846360177686887;
        leg_weights_1D(3) =  0.17814598076194573828004669199609;
        leg_weights_1D(4) =  0.20781604753688850231252321930605;
        leg_weights_1D(5) =  0.22628318026289723841209018603977;
        leg_weights_1D(6) =  0.23255155323087391019458951526883;
        leg_weights_1D(7) =  0.22628318026289723841209018603977;
        leg_weights_1D(8) =  0.20781604753688850231252321930605;
        leg_weights_1D(9) =  0.17814598076194573828004669199609;
        leg_weights_1D(10) = 0.13887351021978723846360177686887;
        leg_weights_1D(11) = 0.09212149983772844791442177595379;
        leg_weights_1D(12) = 0.04048400476531587952002159220098;
    }
    
    else if (num == 14){
        leg_weights_1D(0) =  0.03511946033175186303183287613819;
        leg_weights_1D(1) =  0.08015808715976020980563327706285;
        leg_weights_1D(2) =  0.12151857068790318468941480907247;
        leg_weights_1D(3) =  0.15720316715819353456960193862384;
        leg_weights_1D(4) =  0.18553839747793781374171659012515;
        leg_weights_1D(5) =  0.20519846372129560396592406566121;
        leg_weights_1D(6) =  0.21526385346315779019587644331626;
        leg_weights_1D(7) =  0.21526385346315779019587644331626;
        leg_weights_1D(8) =  0.20519846372129560396592406566121;
        leg_weights_1D(9) =  0.18553839747793781374171659012515;
        leg_weights_1D(10) = 0.15720316715819353456960193862384;
        leg_weights_1D(11) = 0.12151857068790318468941480907247;
        leg_weights_1D(12) = 0.08015808715976020980563327706285;
        leg_weights_1D(13) = 0.03511946033175186303183287613819;
    }
    
    
    else if (num == 15){
        leg_weights_1D(0) =  0.03075324199611726835462839357720;
        leg_weights_1D(1) =  0.07036604748810812470926741645066;
        leg_weights_1D(2) =  0.10715922046717193501186954668586;
        leg_weights_1D(3) =  0.13957067792615431444780479451102;
        leg_weights_1D(4) =  0.16626920581699393355320086048120;
        leg_weights_1D(5) =  0.18616100001556221102680056186642;
        leg_weights_1D(6) =  0.19843148532711157645611832644383;
        leg_weights_1D(7) =  0.20257824192556127288062019996751;
        leg_weights_1D(8) =  0.19843148532711157645611832644383;
        leg_weights_1D(9) =  0.18616100001556221102680056186642;
        leg_weights_1D(10) = 0.16626920581699393355320086048120;
        leg_weights_1D(11) = 0.13957067792615431444780479451102;
        leg_weights_1D(12) = 0.10715922046717193501186954668586;
        leg_weights_1D(13) = 0.07036604748810812470926741645066;
        leg_weights_1D(14) = 0.03075324199611726835462839357720;
    }
    
    
    else if (num == 16){
        leg_weights_1D(0) =  0.02715245941175409485178057245601;
        leg_weights_1D(1) =  0.06225352393864789286284383699437;
        leg_weights_1D(2) =  0.09515851168249278480992510760224;
        leg_weights_1D(3) =  0.12462897125553387205247628219201;
        leg_weights_1D(4) =  0.14959598881657673208150173054747;
        leg_weights_1D(5) =  0.16915651939500253818931207903035;
        leg_weights_1D(6) =  0.18260341504492358886676366796921;
        leg_weights_1D(7) =  0.18945061045506849628539672320828;
        leg_weights_1D(8) =  0.18945061045506849628539672320828;
        leg_weights_1D(9) =  0.18260341504492358886676366796921;
        leg_weights_1D(10) = 0.16915651939500253818931207903035;
        leg_weights_1D(11) = 0.14959598881657673208150173054747;
        leg_weights_1D(12) = 0.12462897125553387205247628219201;
        leg_weights_1D(13) = 0.09515851168249278480992510760224;
        leg_weights_1D(14) = 0.06225352393864789286284383699437;
        leg_weights_1D(15) = 0.02715245941175409485178057245601;
    }
    
    
    else if (num == 17){
        leg_weights_1D(0) =  0.02414830286854793196011002628756;
        leg_weights_1D(1) =  0.05545952937398720112944016535824;
        leg_weights_1D(2) =  0.08503614831717918088353537019106;
        leg_weights_1D(3) =  0.11188384719340397109478838562635;
        leg_weights_1D(4) =  0.13513636846852547328631998170235;
        leg_weights_1D(5) =  0.15404576107681028808143159480195;
        leg_weights_1D(6) =  0.16800410215645004450997066378832;
        leg_weights_1D(7) =  0.17656270536699264632527099011319;
        leg_weights_1D(8) =  0.17944647035620652545826564426188;
        leg_weights_1D(9) =  0.17656270536699264632527099011319;
        leg_weights_1D(10) = 0.16800410215645004450997066378832;
        leg_weights_1D(11) = 0.15404576107681028808143159480195;
        leg_weights_1D(12) = 0.13513636846852547328631998170235;
        leg_weights_1D(13) = 0.11188384719340397109478838562635;
        leg_weights_1D(14) = 0.08503614831717918088353537019106;
        leg_weights_1D(15) = 0.05545952937398720112944016535824;
        leg_weights_1D(16) = 0.02414830286854793196011002628756;
    }
    
    else if (num == 18){
        leg_weights_1D(0) =  0.02161601352648331031334271026645;
        leg_weights_1D(1) =  0.04971454889496979645333494620263;
        leg_weights_1D(2) =  0.07642573025488905652912967761663;
        leg_weights_1D(3) =  0.10094204410628716556281398492483;
        leg_weights_1D(4) =  0.12255520671147846018451912680020;
        leg_weights_1D(5) =  0.14064291467065065120473130375194;
        leg_weights_1D(6) =  0.15468467512626524492541800383637;
        leg_weights_1D(7) =  0.16427648374583272298605377646592;
        leg_weights_1D(8) =  0.16914238296314359184065647013498;
        leg_weights_1D(9) =  0.16914238296314359184065647013498;
        leg_weights_1D(10) = 0.16427648374583272298605377646592;
        leg_weights_1D(11) = 0.15468467512626524492541800383637;
        leg_weights_1D(12) = 0.14064291467065065120473130375194;
        leg_weights_1D(13) = 0.12255520671147846018451912680020;
        leg_weights_1D(14) = 0.10094204410628716556281398492483;
        leg_weights_1D(15) = 0.07642573025488905652912967761663;
        leg_weights_1D(16) = 0.04971454889496979645333494620263;
        leg_weights_1D(17) = 0.02161601352648331031334271026645;
    }
    
    else if (num == 19) {
        leg_weights_1D(0) =  0.01946178822972647703631204146443;
        leg_weights_1D(1) =  0.04481422676569960033283815740199;
        leg_weights_1D(2) =  0.06904454273764122658070825800601;
        leg_weights_1D(3) =  0.09149002162244999946446209412383;
        leg_weights_1D(4) =  0.11156664554733399471602390168176;
        leg_weights_1D(5) =  0.12875396253933622767551578485687;
        leg_weights_1D(6) =  0.14260670217360661177574610944190;
        leg_weights_1D(7) =  0.15276604206585966677885540089766;
        leg_weights_1D(8) =  0.15896884339395434764995643946504;
        leg_weights_1D(9) =  0.16105444984878369597916362532091;
        leg_weights_1D(10) = 0.15896884339395434764995643946504;
        leg_weights_1D(11) = 0.15276604206585966677885540089766;
        leg_weights_1D(12) = 0.14260670217360661177574610944190;
        leg_weights_1D(13) = 0.12875396253933622767551578485687;
        leg_weights_1D(14) = 0.11156664554733399471602390168176;
        leg_weights_1D(15) = 0.09149002162244999946446209412383;
        leg_weights_1D(16) = 0.06904454273764122658070825800601;
        leg_weights_1D(17) = 0.04481422676569960033283815740199;
        leg_weights_1D(18) = 0.01946178822972647703631204146443;
    } // end if
    
    
} // end of legendre_weights_1D function

/**************************************************************************************//**
*  length_weights partitions quadrature weights corresponding the 1D nodal positions defined 
*  on [-1,1] using a distance weighted partition. The CArray len_weights_1D is passed 
*  in my reference and modified in place. The CArray lob_weights_1D and lob_nodes_1D are 
*  passed in and the weights are partitioned. The integer p_order is the numer of kinematic
*  polynomial order of the desired element. Note: This function currently only supports up 
*  to third order elements. 
*****************************************************************************************/
void length_weights(
    CArray <real_t> &len_weights_1D,  // partitioned Lobbatto weights
    CArray <real_t> &lob_weights_1D,  // Lobbatto weights
    CArray <real_t> &lob_nodes_1D,
    const int &p_order){

    real_t alpha1 = (lob_nodes_1D(1) - lob_nodes_1D(0) - lob_weights_1D(0))
                    /lob_weights_1D(1);

    real_t alpha2 = (lob_nodes_1D(2) - lob_nodes_1D(0) 
                  - (lob_weights_1D(0)+ lob_weights_1D(1)))
                  /  lob_weights_1D(2);


    if(p_order == 1){
        len_weights_1D(0) = 1.0;
        len_weights_1D(1) = 1.0;
    }


    if(p_order == 2){
        len_weights_1D(0) = lob_weights_1D(0) + alpha1*lob_weights_1D(1);
        len_weights_1D(1) = (1.0-alpha1)*lob_weights_1D(1) + 0.5*lob_weights_1D(2);
        len_weights_1D(2) = len_weights_1D(1);
        len_weights_1D(3) = len_weights_1D(0);
    }

    if(p_order == 3){
        len_weights_1D(0) = lob_weights_1D(0) + alpha1*lob_weights_1D(1);
        len_weights_1D(1) = (1.0 - alpha1)*lob_weights_1D(1) + alpha2*(lob_weights_1D(2));
        len_weights_1D(2) = (1.0 - alpha2)*lob_weights_1D(2) + 0.5*lob_weights_1D(3);
        len_weights_1D(3) = len_weights_1D(2);
        len_weights_1D(4) = len_weights_1D(1);
        len_weights_1D(5) = len_weights_1D(0);
    }
}


/**************************************************************************************//**
*  sub_weights partitions quadrature weights to the corners corresponding the 1D nodal 
*  positions defined on [-1,1] using a distance weighted partition.
*****************************************************************************************/
void sub_weights(
    CArray <real_t> &sub_weights_1D,  // Labbatto weights
    CArray <real_t> &lob_weights_1D,  // Labbatto weights
    CArray <real_t> &lob_nodes_1D,
    const int &p_order){

    real_t alpha1 = (lob_nodes_1D(1) - lob_nodes_1D(0) - lob_weights_1D(0))
                    /lob_weights_1D(1);

    real_t alpha2 = (lob_nodes_1D(2) - lob_nodes_1D(0) 
                  - (lob_weights_1D(0)+ lob_weights_1D(1)))
                  /  lob_weights_1D(2);

    if(p_order == 0){
        sub_weights_1D(0) = lob_weights_1D(0);
        sub_weights_1D(1) = lob_weights_1D(1);
    }

    if(p_order == 1){
        sub_weights_1D(0) = lob_weights_1D(0);
        sub_weights_1D(1) = 0.5*lob_weights_1D(1);
        sub_weights_1D(2) = sub_weights_1D(1);
        sub_weights_1D(3) = sub_weights_1D(0);
    }


    if(p_order == 2){
        sub_weights_1D(0) = lob_weights_1D(0);
        sub_weights_1D(1) = alpha1*lob_weights_1D(1);
        sub_weights_1D(2) = (1.0-alpha1)*lob_weights_1D(1);
        sub_weights_1D(3) = 0.5*lob_weights_1D(2);
        sub_weights_1D(4) = sub_weights_1D(3);
        sub_weights_1D(5) = sub_weights_1D(2);
        sub_weights_1D(6) = sub_weights_1D(1);
        sub_weights_1D(7) = sub_weights_1D(0);
    }

    if(p_order == 3){
        sub_weights_1D(0) = lob_weights_1D(0);
        sub_weights_1D(1) = alpha1*lob_weights_1D(1);
        sub_weights_1D(2) = (1.0-alpha1)*lob_weights_1D(1);
        sub_weights_1D(3) = alpha2*lob_weights_1D(2);
        sub_weights_1D(4) = (1.0-alpha2)*lob_weights_1D(2);
        sub_weights_1D(5) = 0.5*lob_weights_1D(3);
        sub_weights_1D(6) = sub_weights_1D(5);
        sub_weights_1D(7) = sub_weights_1D(4);
        sub_weights_1D(8) = sub_weights_1D(3);
        sub_weights_1D(9) = sub_weights_1D(2);
        sub_weights_1D(10) = sub_weights_1D(1);
        sub_weights_1D(11) = sub_weights_1D(0);
    }
}

/**************************************************************************************//**
*  mat_inverse is a light weight function for inverting a 3X3 matrix. 
*****************************************************************************************/
void mat_inverse(
    ViewCArray <real_t> &mat_inv,
    ViewCArray <real_t> &matrix){

    // computes the inverse of a matrix m
    real_t det_a = matrix(0, 0) * (matrix(1, 1) * matrix(2, 2) - matrix(2, 1) * matrix(1, 2)) -
                   matrix(0, 1) * (matrix(1, 0) * matrix(2, 2) - matrix(1, 2) * matrix(2, 0)) +
                   matrix(0, 2) * (matrix(1, 0) * matrix(2, 1) - matrix(1, 1) * matrix(2, 0));

    real_t invdet = 1.0 / det_a;

    mat_inv(0, 0) = (matrix(1, 1) * matrix(2, 2) - matrix(2, 1) * matrix(1, 2)) * invdet;
    mat_inv(0, 1) = (matrix(0, 2) * matrix(2, 1) - matrix(0, 1) * matrix(2, 2)) * invdet;
    mat_inv(0, 2) = (matrix(0, 1) * matrix(1, 2) - matrix(0, 2) * matrix(1, 1)) * invdet;
    mat_inv(1, 0) = (matrix(1, 2) * matrix(2, 0) - matrix(1, 0) * matrix(2, 2)) * invdet;
    mat_inv(1, 1) = (matrix(0, 0) * matrix(2, 2) - matrix(0, 2) * matrix(2, 0)) * invdet;
    mat_inv(1, 2) = (matrix(1, 0) * matrix(0, 2) - matrix(0, 0) * matrix(1, 2)) * invdet;
    mat_inv(2, 0) = (matrix(1, 0) * matrix(2, 1) - matrix(2, 0) * matrix(1, 1)) * invdet;
    mat_inv(2, 1) = (matrix(2, 0) * matrix(0, 1) - matrix(0, 0) * matrix(2, 1)) * invdet;
    mat_inv(2, 2) = (matrix(0, 0) * matrix(1, 1) - matrix(1, 0) * matrix(0, 1)) * invdet;


}


// /**************************************************************************************//**
// *  mat_mult is a light weight function for multiplying two 3X3 matrices
// *****************************************************************************************/
// void mat_mult(
//     CArray <real_t> &result,
//     CArray <real_t> &A,
//     CArray <real_t> &B){
//
//     result(0, 0) = A(0, 0)*B(0, 0) + A(0, 1)*B(1, 0) + A(0, 2)*B(2, 0);
//     result(0, 1) = A(0, 0)*B(0, 1) + A(0, 1)*B(1, 1) + A(0, 2)*B(2, 1);
//     result(0, 2) = A(0, 0)*B(0, 2) + A(0, 1)*B(1, 2) + A(0, 2)*B(2, 2);
//     result(1, 0) = A(1, 0)*B(0, 0) + A(1, 1)*B(1, 0) + A(1, 2)*B(2, 0);
//     result(1, 1) = A(1, 0)*B(0, 1) + A(1, 1)*B(1, 1) + A(1, 2)*B(2, 1);
//     result(1, 2) = A(1, 0)*B(0, 2) + A(1, 1)*B(1, 2) + A(1, 2)*B(2, 2);
//     result(2, 0) = A(2, 0)*B(0, 0) + A(2, 1)*B(1, 0) + A(2, 2)*B(2, 0);
//     result(2, 1) = A(2, 0)*B(0, 1) + A(2, 1)*B(1, 1) + A(2, 2)*B(2, 1);
//     result(2, 2) = A(2, 0)*B(0, 2) + A(2, 1)*B(1, 2) + A(2, 2)*B(2, 2);
// }


// /**************************************************************************************//**
// *  mat_mult is a light weight function for transposing a 3X3 matrix
// *****************************************************************************************/
// void mat_trans(
//     CArray <real_t> &trans,
//     CArray <real_t> &mat){
//
//     for(int i = 0; i < 3; i++){
//         for(int j = 0; j < 3; j++){
//             trans(i, j) = mat(j, i);
//         }
//     }
// }


/**************************************************************************************//**
*  set_nodes_wgts takes in the CArrays used to hold the quadarture nodes, weights, and 
*  partitioned weights and initializes everyting based of the desired polynomial order
*****************************************************************************************/
void set_nodes_wgts(
    CArray <real_t> &lob_nodes_1D,
    CArray <real_t> &lob_weights_1D,
    CArray <real_t> &len_weights_1D,
    CArray <real_t> &sub_weights_1D, 
    const int p_order){

    int num_g_pts_1d = 2 * p_order + 1;

    // Gauss Lobatto  Weights
    lobatto_weights_1D(lob_weights_1D, num_g_pts_1d);

    // Gauss Lobatto  Nodes
    lobatto_nodes_1D(lob_nodes_1D, num_g_pts_1d);

    // Get the lengths of each edge
    length_weights(len_weights_1D, lob_weights_1D, lob_nodes_1D, p_order);

    // Get the lengths of the partitioned edges (sub_weights)
    sub_weights(sub_weights_1D, lob_weights_1D, lob_nodes_1D, p_order);
}


/**************************************************************************************//**
*  set_unit_normals takes in the CArray defined to hold the unit normals of the corners 
*  in a cell in reference space and initializes them.
*****************************************************************************************/
void set_unit_normals(
    CArray <real_t> &ref_corner_unit_normals){
    
    // i,j,k
    ref_corner_unit_normals(0,0) = -1.0;
    ref_corner_unit_normals(0,1) = -1.0;
    ref_corner_unit_normals(0,2) = -1.0;
    
    // i+1,j,k
    ref_corner_unit_normals(1,0) =  1.0;
    ref_corner_unit_normals(1,1) = -1.0;
    ref_corner_unit_normals(1,2) = -1.0;
    
    // i, j+1, k
    ref_corner_unit_normals(2,0) = -1.0;
    ref_corner_unit_normals(2,1) =  1.0;
    ref_corner_unit_normals(2,2) = -1.0;
    
    // i+1, j+1, k
    ref_corner_unit_normals(3,0) =  1.0;
    ref_corner_unit_normals(3,1) =  1.0;
    ref_corner_unit_normals(3,2) = -1.0;
    
    // i, j, k+1
    ref_corner_unit_normals(4,0) = -1.0;
    ref_corner_unit_normals(4,1) = -1.0;
    ref_corner_unit_normals(4,2) =  1.0;
    
    ref_corner_unit_normals(5,0) =  1.0;
    ref_corner_unit_normals(5,1) = -1.0;
    ref_corner_unit_normals(5,2) =  1.0;
    
    ref_corner_unit_normals(6,0) = -1.0;
    ref_corner_unit_normals(6,1) =  1.0;
    ref_corner_unit_normals(6,2) =  1.0;
    
    ref_corner_unit_normals(7,0) =  1.0;
    ref_corner_unit_normals(7,1) =  1.0;
    ref_corner_unit_normals(7,2) =  1.0;
}


//******************************//
// Useful function definitions  //
//******************************//



/**************************************************************************************//**
*  line_gauss_info is used to create the nodes and weights for Gauss-Legendre quadrature
*  in 1D. This function is is used to create quadrature points in 2D, 3D, and 4D. 
*****************************************************************************************/
void line_gauss_info(
    real_t &x, 
    real_t &w, 
    int &m, 
    int &p){

    m--;
    // creating matrices for weights and points
    real_t g2[2],w3[3],g3[3],w4[4],g4[4],g5[5],w5[5], 
      g6[6],w6[6],g7[7],w7[7],g8[8],w8[8];

    g2[0] = -1.0/sqrt(3.0);
    g2[1] = -1.0*g2[0]; 

    w3[0] = 5.0/9.0;
    w3[1] = 8.0/9.0;
    w3[2] = w3[0]; 

    g3[0] = -sqrt(3.0/5.0);
    g3[1] = 0.0;
    g3[2] = -1.0*g3[0]; 

    w4[0] = (1./2.)-sqrt(5./6.)/6.;
    w4[1] = (1./2.)+sqrt(5./6.)/6.;
    w4[2] = w4[1]; 
    w4[3] = w4[0]; 

    g4[0] = -sqrt((3.+2.*sqrt(6./5.))/7.);
    g4[1] = -sqrt((3.-2.*sqrt(6./5.))/7.);
    g4[2] = -g4[1]; 
    g4[3] = -g4[0]; 

    w5[0] = (322.-13.*sqrt(70.))/900.;
    w5[1] = (322.+13.*sqrt(70.))/900.;
    w5[2] =  512./900.;
    w5[3] = w5[1]; 
    w5[4] = w5[0]; 

    g5[0] = -sqrt(5.+2.*sqrt(10./7.))/3.;
    g5[1] = -sqrt(5.-2.*sqrt(10./7.))/3.;
    g5[2] = 0.0;
    g5[3] = -g5[1]; 
    g5[4] = -g5[0]; 

    w6[0] = 0.1713244923791704;
    w6[1] = 0.3607615730481386;
    w6[2] = 0.4679139345726910; 
    w6[3] = w6[2];
    w6[4] = w6[1];
    w6[5] = w6[0];

    g6[0] = -0.9324695142031521;
    g6[1] = -0.6612093864662645;
    g6[2] = -0.2386191860831969;
    g6[3] = -g6[2];
    g6[4] = -g6[1];
    g6[5] = -g6[0];

    w7[0] = 0.1294849661688697;
    w7[1] = 0.2797053914892766;
    w7[2] = 0.3818300505051189;
    w7[3] = 0.4179591836734694;
    w7[4] = w7[2];
    w7[5] = w7[1];
    w7[6] = w7[0];

    g7[0] = -0.9491079123427585;
    g7[1] = -0.7415311855993945;
    g7[2] = -0.4058451513773972;
    g7[3] =  0.0;
    g7[4] = -g7[2];
    g7[5] = -g7[1];
    g7[6] = -g7[0];

    w8[0] = 0.1012285362903763;
    w8[1] = 0.2223810344533745;
    w8[2] = 0.3137066458778873;
    w8[3] = 0.3626837833783620;
    w8[4] = w8[3];
    w8[5] = w8[2];
    w8[6] = w8[1];
    w8[7] = w8[0];

    g8[0] = -0.9602898564975363;
    g8[1] = -0.7966664774136267;
    g8[2] = -0.5255324099163290;
    g8[3] = -0.1834346424956498;
    g8[4] = -g8[3];
    g8[5] = -g8[2];
    g8[6] = -g8[1];
    g8[7] = -g8[0];

    if (p==1) {x=0.0;w=2.0;}
    if (p==2) {x=g2[m];w=1.0;}
    if (p==3) {x=g3[m];w=w3[m];}
    if (p==4) {x=g4[m];w=w4[m];}
    if (p==5) {x=g5[m];w=w5[m];}  
    if (p==6) {x=g6[m];w=w6[m];} 
    if (p==7) {x=g7[m];w=w7[m];} 
    if (p==8) {x=g8[m];w=w8[m];} 
} // end of line rule function      

// Used by Lobatto 2/3/4D to set Lobatto quadrature points
void line_lobatto_info(
    real_t &x, 
    real_t &w, 
    int &m, 
    int &p){

    m--;
    // creating matrices for weights and points
    real_t L2[2],w3[3],L3[3],w4[4],L4[4],L5[5],w5[5], 
          L6[6],w6[6],L7[7],w7[7],L8[8],w8[8];

    L2[0] = -1.0;
    L2[1] =  1.0;

    w3[0] = 1.0/3.0;
    w3[1] = 4.0/3.0;
    w3[2] = w3[0]; 
        
    L3[0] =  1.0;
    L3[1] =  0.0;
    L3[2] = -1.0; 

    w4[0] = 0.1666666666666666666667;
    w4[1] = 0.8333333333333333333333;
    w4[2] = w4[1]; 
    w4[3] = w4[0]; 

    L4[0] = -1.0;
    L4[1] = -0.447213595499957939282;
    L4[2] = -L4[1]; 
    L4[3] = -L4[0]; 

    L5[0] = -1.0;
    L5[1] = -0.6546536707079771437983;
    L5[2] = 0.0;
    L5[3] = -L5[1]; 
    L5[4] = -L5[0]; 

    w5[0] = 0.1;
    w5[1] = 0.544444444444444444444;
    w5[2] = 0.7111111111111111111111;
    w5[3] = w5[1]; 
    w5[4] = w5[0]; 

    L6[0] = -1.0;
    L6[1] = -0.765055323929464692851;
    L6[2] = -0.2852315164806450963142;
    L6[3] = -L6[2];
    L6[4] = -L6[1];
    L6[5] = -L6[0];


    w6[0] = 0.06666666666666666666667;
    w6[1] = 0.3784749562978469803166;
    w6[2] = 0.5548583770354863530167;
    w6[3] = w6[2];
    w6[4] = w6[1];
    w6[5] = w6[0];

    L7[0] = -1.0;
    L7[1] = -0.830223896278566929872;
    L7[2] = -0.4688487934707142138038;
    L7[3] =  0.0;
    L7[4] = -L7[2];
    L7[5] = -L7[1];
    L7[6] = -L7[0];


    w7[0] = 0.04761904761904761904762;
    w7[1] = 0.276826047361565948011;
    w7[2] = 0.4317453812098626234179;
    w7[3] = 0.487619047619047619048;
    w7[4] = w7[2];
    w7[5] = w7[1];
    w7[6] = w7[0];


    L8[0] = -1.0;
    L8[1] = -0.8717401485096066153375;
    L8[2] = -0.5917001814331423021445;
    L8[3] = -0.2092992179024788687687;
    L8[4] = -L8[3];
    L8[5] = -L8[2];
    L8[6] = -L8[1];
    L8[7] = -L8[0];


    w8[0] = 0.03571428571428571428571;
    w8[1] = 0.210704227143506039383;
    w8[2] = 0.3411226924835043647642;
    w8[3] = 0.4124587946587038815671;
    w8[4] = w8[3];
    w8[5] = w8[2];
    w8[6] = w8[1];
    w8[7] = w8[0];

    if (p==1) {x=0.0;w=2.0;}
    if (p==2) {x=L2[m];w=1.0;}
    if (p==3) {x=L3[m];w=w3[m];}
    if (p==4) {x=L4[m];w=w4[m];}
    if (p==5) {x=L5[m];w=w5[m];}  
    if (p==6) {x=L6[m];w=w6[m];} 
    if (p==7) {x=L7[m];w=w7[m];} 
    if (p==8) {x=L8[m];w=w8[m];} 
} // end of Lobatto line rule function   

// setting gauss quadrature points for 2D elements
void gauss_2d(
    ViewCArray <real_t> &these_g_pts,   // gauss points
    ViewCArray <real_t> &these_weights, // gauss weights
    ViewCArray <real_t> &tot_g_weight,  // 2D product of gauss weights
    int &quad_order){                     // quadrature order (m)

    int tot_pts = (quad_order*quad_order);    // total quad points in 2D

    //find Gauss-Quadrature Points for volume integration
    for (int m = 0; m < tot_pts; m++) {
      
        int i, j;
        real_t x,w;
 
        // sets up the i, j, indices for the line rule implimentation

        j = floor(m/quad_order)+1; 
        i = (m+1) - quad_order*(j-1);

        these_weights(m, 0) = 1.0;
        these_weights(m, 1) = 1.0;
        tot_g_weight(m) = 1.0;

        // xi direction
        line_gauss_info(x,w,i,quad_order); // setting pts/weights in i direction
        these_g_pts(m, 0)  = x; 
        these_weights(m,0)*= w;

        // eta direction
        line_gauss_info(x,w,j,quad_order); // setting pts/weights in j direction
        these_g_pts(m,1)   = x; 
        these_weights(m,1)*= w;

        tot_g_weight(m) = these_weights(m,0)*these_weights(m,1);
    }
} // end Gauss 2D function

// setting gauss quadrature points for 3D elements
void gauss_3d(
    CArray <real_t> &these_g_pts,   // gauss points
    CArray <real_t> &these_weights, // gauss weights
    CArray <real_t> &tot_g_weight,  // 3D product of gauss weights
    int &quad_order){                     // quadrature order (n)

    // total quad points in 3D
    int tot_pts = (quad_order*quad_order*quad_order);  

    //find Gauss-Quadrature Points for volume integration
    for (int m = 0; m < tot_pts; m++) {
      
        int i, j, k, jj;

        real_t x, w;

        // sets up the i, j, k indices for the line rule implimentation
        int p12 = (quad_order * quad_order);

        k=floor(m/p12)+1; 

        jj=(m+1)-p12*(k-1); 
        j=floor((jj-1)/quad_order)+1;

        i=jj-quad_order*(j-1);  

        these_weights(m, 0) = 1.0;
        these_weights(m, 1) = 1.0;
        these_weights(m, 2) = 1.0;
        tot_g_weight(m) = 1.0;

        // xi direction
        line_gauss_info(x,w,i,quad_order); // setting pts/weights in i direction
        these_g_pts(m, 0)   = x; 
        these_weights(m, 0)*= w;

        // eta direction
        line_gauss_info(x,w,j,quad_order); // setting pts/weights in j direction
        these_g_pts(m, 1)   = x; 
        these_weights(m, 1)*= w;

        // mu direction
        line_gauss_info(x,w,k,quad_order); // setting pts/weights in k direction
        these_g_pts(m, 2)   = x; 
        these_weights(m, 2)*= w;

        tot_g_weight(m) = these_weights(m, 0)*these_weights(m, 1)*these_weights(m, 2);
          
    } // end for    
} // end gauss 3D

// setting gauss quadrature points for 4D elements
void gauss_4d(
    ViewCArray <real_t> &these_g_pts, // gauss points
    ViewCArray <real_t> &these_weights, // gauss weights
    int &quad_order, // quadrature order (n)
    const int &dim){  // dimension

    // total quad points in 3D
    int tot_pts = (quad_order*quad_order*quad_order*quad_order);  

    //find Gauss-Quadrature Points for volume integration
    for (int m = 0; m < tot_pts; m++) {
      
        int i, j, k, l, kk, jj;

        real_t x,w;

        real_t a, b, c;

        a = pow(real_t(quad_order), real_t(dim-1.0));
        b = pow(real_t(quad_order), real_t(dim-2.0));

        // sets up the i, j, k indices for the line rule implimentation
        int p12 = (quad_order * quad_order);

        l = floor(m/(a)) + 1.0;

        kk = (m + 1) - (a)*(l - 1);

        k=floor((kk - 1)/(b)) + 1;

        jj=(m+1) - ((b)*(k - 1)) - (a)*(l - 1);

        j=floor((jj-1)/quad_order)+1;

        i=jj-quad_order*(j-1);  

        these_weights(m, 0) = 1.0;
        these_weights(m, 1) = 1.0;
        these_weights(m, 2) = 1.0;
        these_weights(m, 4) = 1.0;

        // xi direction
        line_gauss_info(x,w,i,quad_order); // setting pts/weights in i direction
        these_g_pts(m, 0)   = x; 
        these_weights(m, 0)*= w;

        // eta direction
        line_gauss_info(x,w,j,quad_order); // setting pts/weights in j direction
        these_g_pts(m, 1)   = x; 
        these_weights(m, 1)*= w;

        // mu direction
        line_gauss_info(x,w,k,quad_order); // setting pts/weights in k direction
        these_g_pts(m, 2)   = x; 
        these_weights(m, 2)*= w;

        // tau direction
        line_gauss_info(x,w,l,quad_order); // setting pts/weights in l direction
        these_g_pts(m, 3)   = x; 
        these_weights(m, 3)*= w;

   } // end for        
} // end Gauss 4D function

// setting Gauss-Lobatto quadrature points for 2D elements
void lobatto_2d(
    ViewCArray <real_t> &these_L_pts, // gauss points
    ViewCArray <real_t> &these_weights, // gauss weights
    int &quad_order){ // quadrature order (n)

    int tot_pts = (quad_order*quad_order);    // total quad points in 2D

    //find Gauss-Quadrature Points for volume integration
    for (int m = 0; m < tot_pts; m++) {
      
        int i, j;
        real_t x,w;

        // sets up the i, j, indices for the line rule implimentation

        j = floor(m/quad_order)+1; 
        i = (m+1) - quad_order*(j-1);

        these_weights(m, 0) = 1.0;
        these_weights(m, 1) = 1.0;

        // xi direction
        line_lobatto_info(x,w,i,quad_order); // setting pts/weights in i direction
        these_L_pts(m, 0)   = x; 
        these_weights(m, 0)*= w;

        // eta direction
        line_lobatto_info(x,w,j,quad_order); // setting pts/weights in j direction
        these_L_pts(m, 1)   = x; 
        these_weights(m, 1)*= w;
        
    } // end for
} // end function

// setting Gauss-Lobatto quadrature points for 3D elements
void lobatto_3d(
    ViewCArray <real_t> &these_L_pts, // gauss points
    ViewCArray <real_t> &these_weights, // gauss weights
    int &quad_order){  // quadrature order (n)

    // total quad points in 3D
    int tot_pts = (quad_order*quad_order*quad_order);  

    //find Gauss-Quadrature Points for volume integration
    for (int m = 0; m < tot_pts; m++) {
      
        int i, j, k, jj;

        real_t x,w;

        // sets up the i, j, k indices for the line rule implimentation
        int p12 = (quad_order * quad_order);

        k=floor(m/p12)+1; 

        jj= (m+1)-p12*(k-1); 
        j = floor((jj-1)/quad_order)+1;

        i = jj-quad_order*(j-1);  

        these_weights(m, 0) = 1.0;
        these_weights(m, 1) = 1.0;
        these_weights(m, 2) = 1.0;

        // xi direction
        line_lobatto_info(x,w,i,quad_order); // setting pts/weights in i direction
        these_L_pts(m, 0)   = x; 
        these_weights(m, 0)*= w;

        // eta direction
        line_lobatto_info(x,w,j,quad_order); // setting pts/weights in j direction
        these_L_pts(m, 1)   = x; 
        these_weights(m, 1)*= w;

        // mu direction
        line_lobatto_info(x,w,k,quad_order); // setting pts/weights in k direction
        these_L_pts(m, 2)   = x; 
        these_weights(m, 2)*= w;
          
    } // end for        
} // end function

// setting gauss quadrature points for 4D elements
void lobatto_4d(
    ViewCArray <real_t> &these_L_pts, // gauss points
    ViewCArray <real_t> &these_weights, // gauss weights
    int &quad_order, // quadrature order (n)
    const int &dim){  // dimension

    // total quad points in 3D
    int tot_pts = (quad_order*quad_order*quad_order*quad_order);  

    //find Gauss-Quadrature Points for volume integration
    for (int m = 0; m < tot_pts; m++) {
      
        int i, j, k, l, kk, jj;

        real_t x,w;

        real_t a, b, c;

        a = pow(real_t(quad_order), real_t(dim-1.0)); //to simplify indexing equations
        b = pow(real_t(quad_order), real_t(dim-2.0));

        // sets up the i, j, k, l indices for the line rule implimentation

        l = floor(m/(a)) + 1.0;

        kk = (m + 1) - (a)*(l - 1);

        k = floor((kk - 1)/(b)) + 1;

        jj = (m+1) - ((b)*(k - 1)) - (a)*(l - 1);

        j = floor((jj-1)/quad_order)+1;

        i = jj-quad_order*(j-1);  

        these_weights(m, 0) = 1.0;
        these_weights(m, 1) = 1.0;
        these_weights(m, 2) = 1.0;
        these_weights(m, 3) = 1.0;

        // xi direction
        line_lobatto_info(x,w,i,quad_order); // setting pts/weights in i direction
        these_L_pts(m, 0)   = x; 
        these_weights(m, 0)*= w;

        // eta direction
        line_lobatto_info(x,w,j,quad_order); // setting pts/weights in j direction
        these_L_pts(m, 1)   = x; 
        these_weights(m, 1)*= w;

        // mu direction
        line_lobatto_info(x,w,k,quad_order); // setting pts/weights in k direction
        these_L_pts(m, 2)   = x; 
        these_weights(m, 2)*= w;

        // tau direction
        line_lobatto_info(x,w,l,quad_order); // setting pts/weights in l direction
        these_L_pts(m, 3)   = x; 
        these_weights(m, 3)*= w;
          
   } // end for        
} // end function

//defining the jacobian for 2D elements
void jacobian_2d(
    ViewCArray <real_t> &J_matrix, 
    real_t &det_J,
    const ViewCArray <real_t> &vertices, 
    const ViewCArray <real_t> &this_partial,
    const int &num_verts){

    int dim = 2;

    // setting jacobian matrix to all zeros
    for(int j = 0; j < dim; j++){  // looping over dimension
        for(int k = 0; k < dim; k++){ //looping over dimension
            J_matrix(j, k) = 0.0;
        }// end for k
    } // end for j

    // solving for the jacobian 
    for(int j = 0; j < dim; j++){  // looping over dimension (partial)
        for(int k = 0; k < dim; k++){ //looping over dimension (vertex position)
            for(int this_x_vert = 0; this_x_vert < num_verts; this_x_vert++){ 

                J_matrix(j, k) += vertices(this_x_vert, k)
                                * this_partial(this_x_vert, j);
                
            } // end for num_verts
        } // end for k
    } // end for j

    //calcualate the determinant of the jacobian for 2D matrices
    det_J = J_matrix(0, 0)*J_matrix(1, 1) 
          - J_matrix(0, 1)*J_matrix(1, 0);
} // end of jacobian_2d function

//defining the jacobian for 3D elements
void jacobian_3d(
    ViewCArray <real_t> &J_matrix, 
    real_t &det_J,
    const ViewCArray <real_t> &vertices, 
    const ViewCArray <real_t> &this_partial,
    const int &num_verts){

    const int dim = 3;

    // setting jacobian matrix to all zeros
    for(int j = 0; j < dim; j++){  // looping over dimension
        for(int k = 0; k < dim; k++){ //looping over dimension
            J_matrix(j, k) = 0.0;
        }// end for k
    } // end for j

    // solving for the jacobian 
    for(int j = 0; j < dim; j++){  // looping over dimension (partial)
        for(int k = 0; k < dim; k++){ //looping over dimension (vertex position)
            //looping over node positions
            for(int vert_lid = 0; vert_lid < num_verts; vert_lid++){ 
               
                J_matrix(j, k) += vertices(vert_lid, k)
                                * this_partial(vert_lid, j);
            
            } // end for num_verts
        } // end for k
    } // end for j



    //calcualate the determinant of the jacobian for 2D/3D matrices
    det_J = J_matrix(0, 0) 
          *(J_matrix(1, 1)*J_matrix(2, 2)) - (J_matrix(2, 1)*J_matrix(1, 2))  //group 1
          - J_matrix(0, 1) 
          *(J_matrix(1, 0)*J_matrix(2, 2)) - (J_matrix(2, 0)*J_matrix(1, 2))  // group 2
          + J_matrix(0, 2) 
          *(J_matrix(1, 0)*J_matrix(2, 1)) - (J_matrix(2, 0)*J_matrix(1, 1)); // group 3 
} // end of jacobian function

//defining the jacobian for 4D elements
void jacobian_4d(
    ViewCArray <real_t> &J_matrix, 
    real_t &det_J,
    const ViewCArray <real_t> &vertices, 
    const ViewCArray <real_t> &this_partial,
    const int &num_verts,
    const int &dim){
   

    // setting jacobian matrix to all zeros
    for(int j = 0; j < dim; j++){  // looping over dimension
        for(int k = 0; k < dim; k++){ //looping over dimension
            J_matrix(j, k) = 0.0;
        }// end for k
    } // end for j
   
    // solving for the jacobian 
    for(int j = 0; j < dim; j++){  // looping over dimension (partial)
        for(int k = 0; k < dim; k++){ //looping over dimension (vertex position)
        //looping over node positions
            for(int this_x_vert = 0; this_x_vert < num_verts; this_x_vert++){ 
                J_matrix(j, k) += vertices(this_x_vert, k)
                                * this_partial(this_x_vert, j);
            } // end for num_verts
        } // end for k
    } // end for j
    
    det_J = J_matrix(0, 3) * J_matrix(1, 2) * J_matrix(2, 1) * J_matrix(3, 0) 
          - J_matrix(0, 2) * J_matrix(1, 3) * J_matrix(2, 1) * J_matrix(3, 0) 
          - J_matrix(0, 3) * J_matrix(1, 1) * J_matrix(2, 2) * J_matrix(3, 0) 
          + J_matrix(0, 1) * J_matrix(1, 3) * J_matrix(2, 2) * J_matrix(3, 0) 
          + J_matrix(0, 2) * J_matrix(1, 1) * J_matrix(2, 3) * J_matrix(3, 0) 
          - J_matrix(0, 1) * J_matrix(1, 2) * J_matrix(2, 3) * J_matrix(3, 0) 
          - J_matrix(0, 3) * J_matrix(1, 2) * J_matrix(2, 0) * J_matrix(3, 1) 
          + J_matrix(0, 2) * J_matrix(1, 3) * J_matrix(2, 0) * J_matrix(3, 1) 
          + J_matrix(0, 3) * J_matrix(1, 0) * J_matrix(2, 2) * J_matrix(3, 1) 
          - J_matrix(0, 0) * J_matrix(1, 3) * J_matrix(2, 2) * J_matrix(3, 1) 
          - J_matrix(0, 2) * J_matrix(1, 0) * J_matrix(2, 3) * J_matrix(3, 1) 
          + J_matrix(0, 0) * J_matrix(1, 2) * J_matrix(2, 3) * J_matrix(3, 1) 
          + J_matrix(0, 3) * J_matrix(1, 1) * J_matrix(2, 0) * J_matrix(3, 2) 
          - J_matrix(0, 1) * J_matrix(1, 3) * J_matrix(2, 0) * J_matrix(3, 2) 
          - J_matrix(0, 3) * J_matrix(1, 0) * J_matrix(2, 1) * J_matrix(3, 2) 
          + J_matrix(0, 0) * J_matrix(1, 3) * J_matrix(2, 1) * J_matrix(3, 2) 
          + J_matrix(0, 1) * J_matrix(1, 0) * J_matrix(2, 3) * J_matrix(3, 2) 
          - J_matrix(0, 0) * J_matrix(1, 1) * J_matrix(2, 3) * J_matrix(3, 2) 
          - J_matrix(0, 2) * J_matrix(1, 1) * J_matrix(2, 0) * J_matrix(3, 3) 
          + J_matrix(0, 1) * J_matrix(1, 2) * J_matrix(2, 0) * J_matrix(3, 3) 
          + J_matrix(0, 2) * J_matrix(1, 0) * J_matrix(2, 1) * J_matrix(3, 3) 
          - J_matrix(0, 0) * J_matrix(1, 2) * J_matrix(2, 1) * J_matrix(3, 3) 
          - J_matrix(0, 1) * J_matrix(1, 0) * J_matrix(2, 2) * J_matrix(3, 3) 
          + J_matrix(0, 0) * J_matrix(1, 1) * J_matrix(2, 2) * J_matrix(3, 3);
} // end of jacobian function

//defining the inverse jacobian for 2D element    
void jacobian_inverse_2d(
    ViewCArray <real_t> &J_inverse, 
    const ViewCArray <real_t> &jacobian){

    real_t det = 0.0;
    det = jacobian(0, 0)*jacobian(1, 1) 
        - jacobian(0, 1)*jacobian(1, 0);


    J_inverse(0, 0) =  jacobian(1, 1)/det;
    J_inverse(0, 1) = -jacobian(0, 1)/det;
    J_inverse(1, 0) = -jacobian(1, 0)/det;
    J_inverse(1, 1) =  jacobian(0, 0)/det;
} // end of 2D jacobin inverse

// defining  the inverse of the Jacobian for 3D elements
void jacobian_inverse_3d(
    ViewCArray <real_t> &J_inverse,
    const ViewCArray <real_t> &jacobian){

    real_t A_11 = jacobian(1, 1)*jacobian(2, 2) 
                - jacobian(1, 2)*jacobian(2, 1);

    real_t A_22 = jacobian(2, 2)*jacobian(0, 0) 
                - jacobian(2, 0)*jacobian(0, 2);

    real_t A_33 = jacobian(0, 0)*jacobian(1, 1) 
                - jacobian(0, 1)*jacobian(1, 0);

    real_t A_12 = jacobian(1, 2)*jacobian(2, 0) 
                - jacobian(1, 0)*jacobian(2, 2);

    real_t A_23 = jacobian(2, 0)*jacobian(0, 1) 
                - jacobian(2, 1)*jacobian(0, 0);

    real_t A_31 = jacobian(0, 1)*jacobian(1, 2) 
                - jacobian(0, 2)*jacobian(1, 1);

    real_t A_21 = jacobian(2, 1)*jacobian(0, 2) 
                - jacobian(0, 1)*jacobian(2, 2);

    real_t A_32 = jacobian(0, 2)*jacobian(1, 0) 
                - jacobian(1, 2)*jacobian(0, 0);

    real_t A_13 = jacobian(1, 0)*jacobian(1, 1) 
                - jacobian(2, 0)*jacobian(1, 1);

    real_t  det = jacobian(0, 0)*A_11 + jacobian(0, 1)*A_21 
                + jacobian(0, 2)*A_31;


    J_inverse(0, 0) = A_11/det;
    J_inverse(0, 1) = A_12/det;
    J_inverse(0, 2) = A_13/det;
    J_inverse(1, 0) = A_21/det;
    J_inverse(1, 1) = A_22/det;
    J_inverse(1, 2) = A_23/det;
    J_inverse(2, 0) = A_31/det;
    J_inverse(2, 1) = A_32/det;
    J_inverse(2, 2) = A_33/det;

} // end of inverse jacobian 

// defining  the inverse of the Jacobian for 4D elements
void jacobian_inverse_4d(
    ViewCArray <real_t> &J_inverse,
    const ViewCArray <real_t> &jacobian,
    const real_t &det_J){


    real_t inv[16];
    real_t m[16];
    real_t inv_mat[16];

    // convering jacobian into array length 16
    for (int array = 0; array < 4; array++){ 
        m[array] = jacobian(0, array);
    }
    for (int array = 4; array < 8; array++){ 
        m[array] = jacobian(1, array-4);
    }
    for (int array = 8; array < 12; array++){ 
        m[array] = jacobian(2, array-8);
    }
    for (int array = 12; array < 16; array++){ 
        m[array] = jacobian(3, array-12);     
    }


    inv[0] = m[5]  * m[10] * m[15] 
           - m[5]  * m[11] * m[14] 
           - m[9]  * m[6]  * m[15] 
           + m[9]  * m[7]  * m[14] 
           + m[13] * m[6]  * m[11] 
           - m[13] * m[7]  * m[10];

    inv[4] = -m[4]  * m[10] * m[15] 
           + m[4]  * m[11] * m[14] 
           + m[8]  * m[6]  * m[15] 
           - m[8]  * m[7]  * m[14] 
           - m[12] * m[6]  * m[11] 
           + m[12] * m[7]  * m[10];

    inv[8] = m[4]  * m[9] * m[15] 
           - m[4]  * m[11] * m[13] 
           - m[8]  * m[5] * m[15] 
           + m[8]  * m[7] * m[13] 
           + m[12] * m[5] * m[11] 
           - m[12] * m[7] * m[9];

    inv[12]=-m[4]  * m[9] * m[14] 
           + m[4]  * m[10] * m[13] 
           + m[8]  * m[5] * m[14] 
           - m[8]  * m[6] * m[13] 
           - m[12] * m[5] * m[10] 
           + m[12] * m[6] * m[9];

    inv[1] =-m[1]  * m[10] * m[15] 
           + m[1]  * m[11] * m[14] 
           + m[9]  * m[2] * m[15] 
           - m[9]  * m[3] * m[14] 
           - m[13] * m[2] * m[11] 
           + m[13] * m[3] * m[10];

    inv[5] = m[0]  * m[10] * m[15] 
           - m[0]  * m[11] * m[14] 
           - m[8]  * m[2] * m[15] 
           + m[8]  * m[3] * m[14] 
           + m[12] * m[2] * m[11] 
           - m[12] * m[3] * m[10];

    inv[9] =-m[0]  * m[9] * m[15] 
           + m[0]  * m[11] * m[13] 
           + m[8]  * m[1] * m[15] 
           - m[8]  * m[3] * m[13] 
           - m[12] * m[1] * m[11] 
           + m[12] * m[3] * m[9];

    inv[13]= m[0]  * m[9] * m[14] 
           - m[0]  * m[10] * m[13] 
           - m[8]  * m[1] * m[14] 
           + m[8]  * m[2] * m[13] 
           + m[12] * m[1] * m[10] 
           - m[12] * m[2] * m[9];

    inv[2] = m[1]  * m[6] * m[15] 
           - m[1]  * m[7] * m[14] 
           - m[5]  * m[2] * m[15] 
           + m[5]  * m[3] * m[14] 
           + m[13] * m[2] * m[7] 
           - m[13] * m[3] * m[6];

    inv[6] =-m[0]  * m[6] * m[15] 
           + m[0]  * m[7] * m[14] 
           + m[4]  * m[2] * m[15] 
           - m[4]  * m[3] * m[14] 
           - m[12] * m[2] * m[7] 
           + m[12] * m[3] * m[6];

    inv[10] = m[0]  * m[5] * m[15] 
           - m[0]  * m[7] * m[13] 
           - m[4]  * m[1] * m[15] 
           + m[4]  * m[3] * m[13] 
           + m[12] * m[1] * m[7] 
           - m[12] * m[3] * m[5];

    inv[14]=-m[0]  * m[5] * m[14] 
           + m[0]  * m[6] * m[13] 
           + m[4]  * m[1] * m[14] 
           - m[4]  * m[2] * m[13] 
           - m[12] * m[1] * m[6] 
           + m[12] * m[2] * m[5];

    inv[3] =-m[1] * m[6] * m[11] 
           + m[1] * m[7] * m[10] 
           + m[5] * m[2] * m[11] 
           - m[5] * m[3] * m[10] 
           - m[9] * m[2] * m[7] 
           + m[9] * m[3] * m[6];

    inv[7] =  m[0] * m[6] * m[11] 
           - m[0] * m[7] * m[10] 
           - m[4] * m[2] * m[11] 
           + m[4] * m[3] * m[10] 
           + m[8] * m[2] * m[7] 
           - m[8] * m[3] * m[6];

    inv[11]= -m[0] * m[5] * m[11] 
           +  m[0] * m[7] * m[9] 
           +  m[4] * m[1] * m[11] 
           -  m[4] * m[3] * m[9] 
           -  m[8] * m[1] * m[7] 
           +  m[8] * m[3] * m[5];

    inv[15]= m[0] * m[5] * m[10] 
           - m[0] * m[6] * m[9] 
           - m[4] * m[1] * m[10] 
           + m[4] * m[2] * m[9] 
           + m[8] * m[1] * m[6] 
           - m[8] * m[2] * m[5];

    real_t det_inv = (1.0 / det_J);

    for (int i = 0; i < 16; i++){
        inv_mat[i] = inv[i] * det_inv;
    }
   
   // convering inverse jacobian back to 2D array
    for (int array = 0; array < 4; array++){ 
        J_inverse(0, array) = inv_mat[array];
    }

    for (int array = 4; array < 8; array++){
        J_inverse(1, array-4) = inv_mat[array];      
    }

    for (int array = 8; array < 12; array++){
        J_inverse(2, array-8) = inv_mat[array];    
    }

    for (int array = 12; array < 16; array++){ 
        J_inverse(3, array-12) = inv_mat[array];          
    }
} // end of quad point inverse jacobian functions

// creates nodal positions with Chebyshev spacing
void chebyshev_nodes_1D(
    ViewCArray <real_t> &cheb_nodes_1D,   // Chebyshev nodes
    const int &order){                      // Interpolation order

    real_t pi = 3.14159265358979323846;

    // loop to build the base set of Chebyshev nodes
    for (int i = 1; i < order + 1; i++){
        cheb_nodes_1D(i - 1) = -cos(pi*(2.0*i - 1.0)/(2.0*(order + 1.0)));
    } // end for i

    //replacing the first and last index with the element boundary 
    cheb_nodes_1D(0) = -1.0;
    cheb_nodes_1D(order) = 1.0;
}






//***********************************************//
// Reference element class function definitions  //
//***********************************************//


void ref_element::init(int p_order, int num_dim, HexN &elem){ 
    
    num_dim_ = num_dim;
    elem_ptr = &elem;

    int num_g_pts_1d;

    if(p_order == 0){       
        
        num_g_pts_1d = 2;
        num_ref_nodes_1D_ = num_g_pts_1d;
        num_ref_verts_1d_ = 2;
        num_zones_1d_ = 1;
        num_zones_in_elem_ = num_zones_1d_*num_zones_1d_*num_zones_1d_;
    
        cells_in_zone_list_ = CArray <int> (num_zones_in_elem_, 1);

    }

    else{
        
        num_g_pts_1d = 2 * p_order + 1; // num gauss points in 1d
        num_ref_nodes_1D_ = num_g_pts_1d;
        num_ref_verts_1d_ = p_order+1;
        num_zones_1d_ = (num_ref_nodes_1D_ - 1) / 2;
        num_zones_in_elem_ = num_zones_1d_*num_zones_1d_*num_zones_1d_;

        cells_in_zone_list_ = CArray <int> (num_zones_in_elem_, 8);


    }



    num_ref_cells_1D_ = num_ref_nodes_1D_ - 1;
    
    num_ref_corners_1D_ = 2*(num_ref_nodes_1D_ - 2) + 2;

 
    num_ref_nodes_in_elem_ =
        num_ref_nodes_1D_*num_ref_nodes_1D_*num_ref_nodes_1D_;

    num_ref_verts_in_elem_ = num_ref_verts_1d_*num_ref_verts_1d_*num_ref_verts_1d_;
    
    num_ref_cells_in_elem_ =
        (num_ref_nodes_1D_-1)*(num_ref_nodes_1D_-1)*(num_ref_nodes_1D_-1);

    std::cout<<"Num cells in element reference  = "<<num_ref_cells_in_elem_<<std::endl;
    
    cell_nodes_in_elem_list_ = CArray <int> (num_ref_cells_in_elem_, 8);
    
    num_ref_corners_in_cell_ = 8;
    
    num_ref_corners_in_elem_ =
        num_ref_corners_1D_*num_ref_corners_1D_*num_ref_corners_1D_;
    
    num_basis_ = num_ref_verts_in_elem_;

    



    // allocate memory
    ref_nodes_in_cell_ = CArray <int> (num_ref_corners_in_elem_);

    ref_corners_in_cell_ = CArray <int> (num_ref_corners_in_elem_);

    ref_corner_g_weights_ = CArray <real_t> (num_ref_corners_in_elem_);

    ref_corner_surf_g_weights_ = CArray <real_t> (num_ref_corners_in_elem_, num_dim_);
    
    ref_corner_surf_normals_ = CArray <real_t> (num_ref_corners_in_elem_, num_dim_, num_dim_);
    
    ref_node_positions_ = CArray <real_t> (num_ref_nodes_in_elem_, num_dim_);
    
    ref_node_g_weights_ = CArray <real_t> (num_ref_nodes_in_elem_);

    // Memory for gradients
    ref_nodal_gradient_ = CArray <real_t> (num_ref_nodes_in_elem_, num_basis_, num_dim_);

    // Basis evaluation at the nodes
    ref_nodal_basis_ = CArray <real_t> (num_ref_nodes_in_elem_, num_basis_);



    // --- build reference index spaces for 3D ---
    if(num_dim_ == 3){
        
        int N_1d = num_ref_nodes_1D_; // a temporary variable
        num_ref_inside_nodes_in_elem_  = (N_1d - 2)*(N_1d - 2)*(N_1d - 2);
        num_ref_surface_nodes_in_elem_ = N_1d*N_1d*N_1d  - num_ref_inside_nodes_in_elem_;
        ref_surface_nodes_in_elem_ = CArray <int> (num_ref_surface_nodes_in_elem_);
        ref_inside_nodes_in_elem_  = CArray <int> (num_ref_inside_nodes_in_elem_);
        
        // --- build gauss nodal positions and weights ---
        auto lob_nodes_1D = CArray <real_t> (num_ref_nodes_1D_);
        lobatto_nodes_1D(lob_nodes_1D, num_ref_nodes_1D_);
    
        auto lob_weights_1D = CArray <real_t> (num_ref_nodes_1D_);
        lobatto_weights_1D(lob_weights_1D, num_ref_nodes_1D_);
    
        for(int k = 0; k < num_ref_nodes_1D_; k++){
            for(int j = 0; j < num_ref_nodes_1D_; j++){
                for(int i = 0; i < num_ref_nodes_1D_; i++){
                    
                    int n_rid = node_rid(i,j,k);
                    
                    ref_node_positions_(n_rid,0) = lob_nodes_1D(i);
                    ref_node_positions_(n_rid,1) = lob_nodes_1D(j);
                    ref_node_positions_(n_rid,2) = lob_nodes_1D(k);
                    
                    ref_node_g_weights_(n_rid) = lob_weights_1D(i)*lob_weights_1D(j)*lob_weights_1D(k);
                }
            }
        }
    
        // must partition the nodal guass weights to the corners
        auto corner_lob_weights_1D = CArray <real_t> (num_ref_corners_1D_);
        auto r_corner_part_g_weights = CArray <real_t> (num_ref_corners_in_elem_, num_dim_);
    
        // loop over interior corners in 1D
        corner_lob_weights_1D(0) = lob_weights_1D(0);
        
        for(int i = 1; i < num_ref_nodes_1D_ - 1; i++){
            
            // get the corner_rid index in 1D for the left and right corners
            int corner_left = (2*i) - 1;
            int corner_right = 2*i;
            
            // WARNING WARNING WARNING: partitioning using an average
            corner_lob_weights_1D(corner_left)  = 0.5*lob_weights_1D(i);
            corner_lob_weights_1D(corner_right) = 0.5*lob_weights_1D(i);
        }
        
        corner_lob_weights_1D(num_ref_corners_1D_ - 1) = lob_weights_1D(num_ref_nodes_1D_ - 1);


        // auto corner_lob_weights_1D = CArray <real_t> (num_ref_corners_1D_);
        // auto r_corner_part_g_weights = CArray <real_t> (num_ref_corners_in_elem_, num_dim_);

        // // use geometric partition
        // corner_lob_weights_1D(0) = lob_weights_1D(0);

        // for(int i = 1; i < num_ref_nodes_1D_ - 1; i++){
            
        //     // get the corner_rid index in 1D for the left and right corners
        //     int corner_left = (2*i) - 1;
        //     int corner_right = 2*i;

        //     real_t bottom = ((lob_nodes_1D(i+1) -  lob_nodes_1D(i))/2.0) + ((lob_nodes_1D(i) -  lob_nodes_1D(i-1))/2.0);
            
        //     real_t top = fabs( ((lob_nodes_1D(i) -  lob_nodes_1D(i-1))/2.0) );

            
        //     std::cout<<"ref 1d node = "<<i<<" Top = "<<top<< ", bottom = "<<bottom<<std::endl;
            
        //     real_t alpha_l = top/bottom;
        //     real_t alpha_r = (1.0 - alpha_l);

        //     corner_lob_weights_1D(corner_left)  = alpha_l*lob_weights_1D(i);
        //     corner_lob_weights_1D(corner_right) = alpha_r*lob_weights_1D(i);
            
        // }

        // corner_lob_weights_1D(num_ref_corners_1D_ - 1) = lob_weights_1D(num_ref_nodes_1D_ - 1);

        // std::cout<<std::endl;
        // for(int i=0; i<num_ref_corners_1D_; i++){

        //     std::cout<<"ref corner = "<<i<<" weight= "<<corner_lob_weights_1D(i)<<std::endl;

        // }


        if(p_order == 0){

            cell_lid_in_zone(0, 0) = 0;
        }

        else{
            // Save the Cell_lid to the zones
            int zone_rid = 0;
            for(int k = 0; k < num_zones_1d_; k++){
                for(int j = 0; j < num_zones_1d_; j++){
                    for(int i = 0; i < num_zones_1d_; i++){


                        cell_lid_in_zone(zone_rid, 0) = cell_rid(2*i  , 2*j  , 2*k  );
                        cell_lid_in_zone(zone_rid, 1) = cell_rid(2*i+1, 2*j  , 2*k  );
                        cell_lid_in_zone(zone_rid, 2) = cell_rid(2*i  , 2*j+1, 2*k  );
                        cell_lid_in_zone(zone_rid, 3) = cell_rid(2*i+1, 2*j+1, 2*k  );
                        cell_lid_in_zone(zone_rid, 4) = cell_rid(2*i  , 2*j  , 2*k+1);
                        cell_lid_in_zone(zone_rid, 5) = cell_rid(2*i+1, 2*j  , 2*k+1);
                        cell_lid_in_zone(zone_rid, 6) = cell_rid(2*i  , 2*j+1, 2*k+1);
                        cell_lid_in_zone(zone_rid, 7) = cell_rid(2*i+1, 2*j+1, 2*k+1);

                        zone_rid++;
                    }
                }   
            }

        }
        
        // Save the node in cell lid to node rid in elem map
        int cell_lid = 0;
        int num_ref_cells_1d = (num_ref_nodes_1D_-1);
        for(int k = 0; k < num_ref_cells_1d; k++){
            for(int j = 0; j < num_ref_cells_1d; j++){
                for(int i = 0; i < num_ref_cells_1d; i++){
                    
                    cell_nodes_in_elem(cell_lid, 0) = node_rid(i  , j,   k);
                    cell_nodes_in_elem(cell_lid, 1) = node_rid(i+1, j,   k);
                    cell_nodes_in_elem(cell_lid, 2) = node_rid(i  , j+1, k);
                    cell_nodes_in_elem(cell_lid, 3) = node_rid(i+1, j+1, k);
                    cell_nodes_in_elem(cell_lid, 4) = node_rid(i  , j,   k+1);
                    cell_nodes_in_elem(cell_lid, 5) = node_rid(i+1, j,   k+1);
                    cell_nodes_in_elem(cell_lid, 6) = node_rid(i  , j+1, k+1);
                    cell_nodes_in_elem(cell_lid, 7) = node_rid(i+1, j+1, k+1);
                    
                    cell_lid++;
                }
            }
        }
        
        // i,j,k indicies are for corners
        for(int k = 0; k < num_ref_corners_1D_; k++){
            for(int j = 0; j < num_ref_corners_1D_; j++){
                for(int i = 0; i < num_ref_corners_1D_; i++){
                    
                    int crn_rid = corner_rid(i, j, k);  // the ref space id
                    
                    r_corner_part_g_weights(crn_rid, 0) = corner_lob_weights_1D(i);
                    r_corner_part_g_weights(crn_rid, 1) = corner_lob_weights_1D(j);
                    r_corner_part_g_weights(crn_rid, 2) = corner_lob_weights_1D(k);
                    
                    ref_corner_g_weights_(crn_rid) =
                        corner_lob_weights_1D(i)*corner_lob_weights_1D(j)*corner_lob_weights_1D(k);
                    
                }
            }
        } // end loop over i,j,k for corners in element
    
    

        // --- build corners ---
        auto unit_normals = CArray <real_t> (num_ref_corners_in_cell_, num_dim_);
        
        set_unit_normals(unit_normals);
        
        
        // loop over the cells in the elem (i,j,k are ref cell indices)
        int index = 0; // index = num_cells*num_corners_in_cell + corner_lid
        for(int k = 0; k < num_ref_cells_1D_; k++){
            for(int j = 0; j < num_ref_cells_1D_; j++){
                for(int i = 0; i < num_ref_cells_1D_; i++){
                    
                    int corner_rid_in_cell_0 = 2*i + 2*(num_ref_corners_1D_)*j
                                             + 2*(num_ref_corners_1D_)*(num_ref_corners_1D_)*k;
                    
                    // loop over the corners in the cell
                    int corner_rlid = 0;
                    for(int k_rlid = 0; k_rlid < 2; k_rlid++){
                        for(int j_rlid = 0; j_rlid < 2; j_rlid++){
                            for(int i_rlid = 0; i_rlid < 2; i_rlid++){
                                
                                // calculate the reference corner index from the rlid's
                                int crn_rid = corner_rid_in_cell_0
                                    + i_rlid + (num_ref_corners_1D_)*j_rlid
                                    + (num_ref_corners_1D_)*(num_ref_corners_1D_)*k_rlid;
                                
                                ref_corners_in_cell_(index) = crn_rid; // save the rid
                                
                                // node ref index
                                ref_nodes_in_cell_(index) = node_rid(i + i_rlid, j + j_rlid, k + k_rlid);
                                int n_rid = node_rid(i + i_rlid, j + j_rlid, k + k_rlid);
                                
                                
                                // 3 surfaces vectors in each ref corner that have 3 components
                                real_t surf_vec0[3] = {unit_normals(corner_rlid,0), 0.0, 0.0};  // s_0
                                real_t surf_vec1[3] = {0.0, unit_normals(corner_rlid,1), 0.0};  // s_1
                                real_t surf_vec2[3] = {0.0, 0.0, unit_normals(corner_rlid,2)};  // s_2
                                
                                
                                // surface unit normal 0 and surface quadrature 0
                                int surf_rlid = 0;
                                for(int dim = 0; dim < num_dim_; dim++){
                                    ref_corner_surf_normals_(crn_rid, surf_rlid, dim) = surf_vec0[dim];
                                }
                                
                                // power coef is =1 for the quadrature values for the surf normal else =0
                                ref_corner_surf_g_weights_(crn_rid, surf_rlid) =
                                      pow( r_corner_part_g_weights(crn_rid, 0), (1.0 - fabs(surf_vec0[0])) )
                                    * pow( r_corner_part_g_weights(crn_rid, 1), (1.0 - fabs(surf_vec0[1])) )
                                    * pow( r_corner_part_g_weights(crn_rid, 2), (1.0 - fabs(surf_vec0[2])) );
                                
                                
                                surf_rlid = 1;
                                
                                for(int dim = 0; dim < num_dim_; dim++){
                                    ref_corner_surf_normals_(crn_rid, surf_rlid, dim) = surf_vec1[dim];
                                }

                                // power coef is =1 for the quadrature values for the surf normal else =0
                                ref_corner_surf_g_weights_(crn_rid, surf_rlid) =
                                      pow( r_corner_part_g_weights(crn_rid, 0), (1.0 - fabs(surf_vec1[0])) )
                                    * pow( r_corner_part_g_weights(crn_rid, 1), (1.0 - fabs(surf_vec1[1])) )
                                    * pow( r_corner_part_g_weights(crn_rid, 2), (1.0 - fabs(surf_vec1[2])) );
                                
                                surf_rlid = 2;
                                
                                for (int dim = 0; dim < num_dim_; dim++){
                                    ref_corner_surf_normals_(crn_rid, surf_rlid, dim) = surf_vec2[dim];
                                }
                                
                                // power coef is =1 for the quadrature values for the surf normal else =0
                                ref_corner_surf_g_weights_(crn_rid, surf_rlid) =
                                      pow( r_corner_part_g_weights(crn_rid, 0), (1.0 - fabs(surf_vec2[0])) )
                                    * pow( r_corner_part_g_weights(crn_rid, 1), (1.0 - fabs(surf_vec2[1])) )
                                    * pow( r_corner_part_g_weights(crn_rid, 2), (1.0 - fabs(surf_vec2[2])) );
                                

                                index++;       // increment the index in the ref element
                                corner_rlid++; // increment the corner index in the ref cell
                                
                            }
                        }
                    } // end of loop over corners in ref cell 
                }
            }
        } // end of loop over the ref cells in element

        // Set up tensor product element
        elem_ptr->setup_HexN(p_order);


        // --- evaluate the basis at the nodal positions
        for(int node_rlid = 0; node_rlid < num_ref_nodes_in_elem_; node_rlid++){

            auto point = CArray <real_t> (3);

            // Get the nodal coordinates
            for(int dim = 0; dim < 3; dim++){
                point(dim) = ref_node_positions_(node_rlid, dim);
            }

            auto node_basis = CArray <real_t> (num_ref_verts_in_elem_);

            elem.basis(node_basis, point);

            for(int vert_rlid = 0; vert_rlid < num_ref_verts_in_elem_; vert_rlid++){

                ref_nodal_basis_(node_rlid, vert_rlid) = node_basis(vert_rlid);
            }

        }


        // --- evaluate grad_basis functions at the ref nodes ---

        auto partial_xi  = CArray <real_t> (num_ref_nodes_in_elem_);
        auto partial_eta = CArray <real_t> (num_ref_nodes_in_elem_);
        auto partial_mu  = CArray <real_t> (num_ref_nodes_in_elem_);

        

        for(int node_lid = 0; node_lid < num_ref_nodes_in_elem_; node_lid++){

            auto point = CArray <real_t> (3);
            
            // Get the nodal coordinates
            for(int dim = 0; dim < 3; dim++){
                point(dim) = ref_node_positions_(node_lid, dim);
            }

            elem.partial_xi_basis(partial_xi, point);
            elem.partial_eta_basis(partial_eta, point);
            elem.partial_mu_basis(partial_mu, point);

            for(int basis_id = 0; basis_id < num_ref_verts_in_elem_; basis_id++){


                ref_nodal_gradient_(node_lid, basis_id, 0) = partial_xi(basis_id);
                ref_nodal_gradient_(node_lid, basis_id, 1) = partial_eta(basis_id);
                ref_nodal_gradient_(node_lid, basis_id, 2) = partial_mu(basis_id);

                partial_xi(basis_id)  = 0.0;
                partial_eta(basis_id) = 0.0;
                partial_mu(basis_id)  = 0.0;
            }
        }
        
        // build a local rlid for the interior and surface nodes of the ref element
        // remember that N_1d = num_ref_nodes_1D_;
        int count_surf = 0;
        int count_inside = 0;
        for (int k=0; k<N_1d; k++){
            for (int j=0; j<N_1d; j++){
                for (int i=0; i<N_1d; i++){
                    
                    int rid = node_rid(i,j,k); // follows i,j,k convention
                    
                    if (i>0 && i<N_1d-1 &&
                        j>0 && j<N_1d-1 &&
                        k>0 && k<N_1d-1)
                    {
                        ref_inside_nodes_in_elem_(count_inside) = rid;
                        count_inside ++;
                    }
                    else
                    {
                        ref_surface_nodes_in_elem_(count_surf) = rid;
                        count_surf ++;
                    }
                    
                } // end for
            } // end for
        } // end for
        // checking the data structure
        if (num_ref_inside_nodes_in_elem_ < count_inside) {
            std::cout << "*** Error in inside nodes in ref elem ***" << std::endl;
        }
        if (num_ref_surface_nodes_in_elem_ < count_surf) {
            std::cout << "*** Error in surface nodes in ref elem ***" << std::endl;
        }
        
        
        // ---- build reference patches and reference sides of a cell and assign guass values ----
        
        num_patches_in_elem_ = (num_ref_cells_1D_+1) * (num_ref_cells_1D_*num_ref_cells_1D_)*3;
        num_sides_in_elem_ = num_ref_cells_in_elem_*6;
        ref_patches_in_cell_list_ = CArray <int> (num_sides_in_elem_);
        
        
        // allocate memory for the 1D Gauss Legendre points and weights
        auto leg_points_1D = CArray <real_t> (num_ref_cells_1D_);
        legendre_nodes_1D(leg_points_1D, num_ref_cells_1D_);
        
        auto leg_weights_1D = CArray <real_t> (num_ref_cells_1D_);
        legendre_weights_1D(leg_weights_1D, num_ref_cells_1D_);
        
        
        // allocate memory for global variables related to Gauss Legendre points and weights
        ref_cell_positions_ = CArray <real_t> (num_ref_cells_in_elem_, 3);
        ref_cell_g_weights_ = CArray <real_t> (num_ref_cells_in_elem_); // this one
        ref_patch_positions_ = CArray <real_t> (num_patches_in_elem_, 3);
        ref_patch_g_weights_ = CArray <real_t> (num_patches_in_elem_);

        
        
        for (int side_rid = 0; side_rid < num_sides_in_elem_; side_rid++){
            ref_patches_in_cell_list_(side_rid) = -1;
        }
        
        int patch_rid = 0;  // the patch reference index
        // loop over the cells
        for (int k=0; k<num_ref_cells_1D_; k++){
            for (int j=0; j<num_ref_cells_1D_; j++){
                for (int i=0; i<num_ref_cells_1D_; i++){
                    
                    // get the cell_rid
                    int this_cell_rid = cell_rid(i, j, k);
                    
                    // save the gauss point volume values at cell
                    // i,j,k tensor product for gauss Legendre
                    ref_cell_positions_(this_cell_rid,0) = leg_points_1D(i);
                    ref_cell_positions_(this_cell_rid,1) = leg_points_1D(j);
                    ref_cell_positions_(this_cell_rid,2) = leg_points_1D(k);
                    
                    ref_cell_g_weights_(this_cell_rid) = leg_weights_1D(i)*leg_weights_1D(j)*leg_weights_1D(k);
                    
                    
                    // loop over the sides in this cell
                    for (int side_lid = 0; side_lid < 6; side_lid++){
                        
                        // get the local side index in the cell
                        int side_rid = side_lid + this_cell_rid*6; // side index
                        
                        
                        // check to see if a patch index was already saved
                        if (ref_patches_in_cell_list_(side_rid) == -1){
                            
                            // save the patch_rid for this patch in the cell
                            ref_patches_in_cell_list_(side_rid) = patch_rid;
                            
                            // save the gauss point area vaules on the patch
                            if (side_lid == 0){
                                
                                ref_patch_positions_(patch_rid,0) = lob_nodes_1D(i);  // xi-coord is the labatto point value at i
                                ref_patch_positions_(patch_rid,1) = leg_points_1D(j); // legendre points
                                ref_patch_positions_(patch_rid,2) = leg_points_1D(k); // legendre points
                                
                                // j,k tensor product for this surface
                                ref_patch_g_weights_(patch_rid) = leg_weights_1D(j)*leg_weights_1D(k);
                            }
                            else if (side_lid == 1){
                                
                                ref_patch_positions_(patch_rid,0) = lob_nodes_1D(i+1); // xi-coord is the labatto point value at i+1
                                ref_patch_positions_(patch_rid,1) = leg_points_1D(j);  // legendre points
                                ref_patch_positions_(patch_rid,2) = leg_points_1D(k);  // legendre points
                                
                                // j,k tensor product for this surface
                                ref_patch_g_weights_(patch_rid) = leg_weights_1D(j)*leg_weights_1D(k);
                            }
                            // end xi direction patches
                            //
                            else if (side_lid == 2){
                                
                                ref_patch_positions_(patch_rid,0) = leg_points_1D(i); // legendre points
                                ref_patch_positions_(patch_rid,1) = lob_nodes_1D(j);  // eta-coord is the labatto point value at j
                                ref_patch_positions_(patch_rid,2) = leg_points_1D(k); // legendre points
                                
                                // i,k tensor product for this surface
                                ref_patch_g_weights_(patch_rid) = leg_weights_1D(i)*leg_weights_1D(k);
                                
                            }
                            else if(side_lid == 3){
                                
                                ref_patch_positions_(patch_rid,0) = leg_points_1D(i);  // legendre points
                                ref_patch_positions_(patch_rid,1) = lob_nodes_1D(j+1); // eta-coord is the labatto point value at j+1
                                ref_patch_positions_(patch_rid,2) = leg_points_1D(k);  // legendre points
                                
                                // i,k tensor product for this surface
                                ref_patch_g_weights_(patch_rid) = leg_weights_1D(i)*leg_weights_1D(k);
                            }
                            // end eta direction patches
                            //
                            else if (side_lid == 4){
                                
                                ref_patch_positions_(patch_rid,0) = leg_points_1D(i); // legendre points
                                ref_patch_positions_(patch_rid,1) = leg_points_1D(j); // legendre points
                                ref_patch_positions_(patch_rid,2) = lob_nodes_1D(k);  // mu-coord is the labatto point value at k
                                
                                // i,j tensor product for this surface
                                ref_patch_g_weights_(patch_rid) = leg_weights_1D(i)*leg_weights_1D(j);
                            }
                            else if (side_lid == 5){
                                
                                ref_patch_positions_(patch_rid,0) = leg_points_1D(i);  // legendre points
                                ref_patch_positions_(patch_rid,1) = leg_points_1D(j);  // legendre points
                                ref_patch_positions_(patch_rid,2) = lob_nodes_1D(k+1); // mu-coord is the labatto point value at k
                                
                                // i,j tensor product for this surface
                                ref_patch_g_weights_(patch_rid) = leg_weights_1D(i)*leg_weights_1D(j);
                            }
                            // end mu direction patches
                                 
                                     
                            // also save the patch_rid in the neighboring cell for this patch
                            // select neighbors for +/- xi, eta, and mu directions
                            int neighbor_cell_rid;
                            if (side_lid == 0 && i>0){
                                neighbor_cell_rid = cell_rid(i-1, j, k);
                            } // end xi minus direction
                            else if (side_lid == 1 && i<num_ref_cells_1D_-1){
                                neighbor_cell_rid = cell_rid(i+1, j, k);
                            } // end xi plus direction
                            else if (side_lid == 2 && j>0){
                                neighbor_cell_rid = cell_rid(i, j-1, k);
                            } // end eta minus direction
                            else if (side_lid == 3 && j<num_ref_cells_1D_-1){
                                neighbor_cell_rid = cell_rid(i, j+1, k);
                            } // end eta plus direction
                            else if (side_lid == 4 && k>0){
                                neighbor_cell_rid = cell_rid(i, j, k-1);
                            } // end mu minus direction
                            else if (side_lid == 5 && k<num_ref_cells_1D_-1){
                                neighbor_cell_rid = cell_rid(i, j, k+1);
                            } // end mu plus direction
                            else{
                                neighbor_cell_rid = -1;
                            } // end no neighboring cell
                            
                            // if the neighbor is valid, then save the patch_rid
                            if (neighbor_cell_rid >= 0 && neighbor_cell_rid < num_ref_cells_in_elem_){
                                
                                // get the patch_lid in the neighboring cell for this patch_lid
                                int neighbor_side_lid = patch_rlid_in_cell_neighbor(side_lid);
                                
                                // get the side index of cell for the same patch
                                int neighbor_side_rid = neighbor_side_lid + (neighbor_cell_rid)*6; // neighboring side index
                                
                                // save the patch_rid for this patch in the neighboring cell
                                ref_patches_in_cell_list_(neighbor_side_rid) = patch_rid;
                                
                            } // end if neighboring_cell_rid is valid
                            
                            
                            // increment the patch_rid index
                            patch_rid ++;
                            
                        }  // end if the patch was saved
                        
                    } // end for sides in a cell
                    
                } // end for i-dir cells
            } // end for j-dir cells
        } // end for k-dir cells
        
        std::cout << "  patch_rid = " << patch_rid << "  num_patches = " << num_patches_in_elem_ << "\n";
        std::cout << "  num cells * 6 = " << num_ref_cells_in_elem_*6 << " and num_cells_1D = "  << num_ref_cells_1D_ << std::endl;
        
        
        // --- evaluate the Lagrange basis at the patch positions
        ref_patch_basis_ =  CArray <real_t> (num_patches_in_elem_, num_ref_verts_in_elem_);
        
        for (int patch_rlid = 0; patch_rlid < num_patches_in_elem_; patch_rlid++){
            
            auto point = CArray <real_t> (3);
            
            // Get the patch coordinates
            for(int dim = 0; dim < 3; dim++){
                point(dim) = ref_patch_positions(patch_rlid, dim);
            }
            
            // the basis function values at the patch for each vertex
            auto patch_basis = CArray <real_t> (num_ref_verts_in_elem_);
            
            // calculate the patch basis function values at the point, for each vertex
            elem.basis(patch_basis, point);
            
            // save the basis values at the patch for each vertex
            for(int vert_rlid = 0; vert_rlid < num_ref_verts_in_elem_; vert_rlid++){
                ref_patch_basis_(patch_rlid, vert_rlid) = patch_basis(vert_rlid);
            }
            
        } // end for patch_rlid
        
        
        
        // --- evaluate grad_basis functions at the ref patches ---
        ref_patch_gradient_ = CArray <real_t> (num_patches_in_elem_, num_basis_, num_dim_);
        
        // loop over the patches
        for (int patch_rlid = 0; patch_rlid < num_patches_in_elem_; patch_rlid++){
            
            auto point = CArray <real_t> (3);
            
            // Get the patch coordinates
            for(int dim = 0; dim < 3; dim++){
                point(dim) = ref_patch_positions(patch_rlid, dim);
            }
            
            // calculate the partials at the patch location for each vertex
            elem.partial_xi_basis(partial_xi, point);
            elem.partial_eta_basis(partial_eta, point);
            elem.partial_mu_basis(partial_mu, point);
            
            // loop over the basis polynomials where there is one from each vertex
            for(int basis_id = 0; basis_id < num_ref_verts_in_elem_; basis_id++){
                
                ref_patch_gradient_(patch_rlid, basis_id, 0) = partial_xi(basis_id);
                ref_patch_gradient_(patch_rlid, basis_id, 1) = partial_eta(basis_id);
                ref_patch_gradient_(patch_rlid, basis_id, 2) = partial_mu(basis_id);
                
                partial_xi(basis_id)  = 0.0;
                partial_eta(basis_id) = 0.0;
                partial_mu(basis_id)  = 0.0;
            } // end for basis_id
            
        } // end for patch_rlid
        
        
        
        // --- evaluate the Lagrange basis at the cell positions
        ref_cell_basis_ = CArray <real_t> (num_ref_cells_in_elem_, num_basis_, num_dim_);
        
        for (int cell_rlid = 0; cell_rlid < num_ref_cells_in_elem_; cell_rlid++){
            
            auto point = CArray <real_t> (3);
            
            // Get the patch coordinates
            for(int dim = 0; dim < 3; dim++){
                point(dim) = ref_cell_positions(cell_rlid, dim);
            }
            
            // the basis function values at the patch for each vertex
            auto cell_basis = CArray <real_t> (num_ref_verts_in_elem_);
            
            // calculate the cell basis function values at the point, for each vertex
            elem.basis(cell_basis, point);
            
            // save the basis values at the patch for each vertex
            for(int vert_rlid = 0; vert_rlid < num_ref_verts_in_elem_; vert_rlid++){
                ref_cell_basis_(cell_rlid, vert_rlid) = cell_basis(vert_rlid);
            }
            
        } // end for cell_rlid
        
        
        // --- evaluate grad_basis functions at the reference cell ---
        ref_cell_gradient_ = CArray <real_t> (num_ref_cells_in_elem_, num_basis_, num_dim_);
        
        // loop over the patches
        for (int cell_rlid = 0; cell_rlid < num_ref_cells_in_elem_; cell_rlid++){
            
            auto point = CArray <real_t> (3);
            
            // Get the cell coordinates
            for(int dim = 0; dim < 3; dim++){
                point(dim) = ref_cell_positions_(cell_rlid, dim);
            }
            
            // calculate the partials at the cell location for each vertex
            elem.partial_xi_basis(partial_xi, point);
            elem.partial_eta_basis(partial_eta, point);
            elem.partial_mu_basis(partial_mu, point);
            
            // loop over the basis polynomials where there is one from each vertex
            for(int basis_id = 0; basis_id < num_ref_verts_in_elem_; basis_id++){
                
                ref_cell_gradient_(cell_rlid, basis_id, 0) = partial_xi(basis_id);
                ref_cell_gradient_(cell_rlid, basis_id, 1) = partial_eta(basis_id);
                ref_cell_gradient_(cell_rlid, basis_id, 2) = partial_mu(basis_id);
                
                partial_xi(basis_id)  = 0.0;
                partial_eta(basis_id) = 0.0;
                partial_mu(basis_id)  = 0.0;
            } // end for basis_id
            
        } // end for patch_rlid
        
    } // end of 3D scope


}; // end of member function

int ref_element::num_dim() const
{
    return num_dim_;
}

int ref_element::num_basis() const
{
    return num_ref_verts_in_elem_;
}

int ref_element::num_ref_nodes() const
{
    return num_ref_nodes_in_elem_;
}

int ref_element::num_ref_cells_in_elem() const 
{
    return num_ref_cells_in_elem_;
};

int ref_element::num_ref_corners_in_cell() const 
{
    return num_ref_corners_in_cell_;
};


// --- ref index access member functions ---

int ref_element::cell_rid(int i, int j, int k) const 
{
    return i + j*num_ref_cells_1D_ + k*num_ref_cells_1D_*num_ref_cells_1D_;
};

int ref_element::node_rid(int i, int j, int k) const 
{
    return i + j*num_ref_nodes_1D_ + k*num_ref_nodes_1D_*num_ref_nodes_1D_;
};

int ref_element::corner_rid(int i, int j, int k) const 
{
    return i + j*num_ref_corners_1D_ + k*num_ref_corners_1D_*num_ref_corners_1D_;
};



// DANIELLOOK
int ref_element::ref_corners_in_cell(int cell_rid, int corner_rlid) const 
{
    return ref_corners_in_cell_(corner_rlid + cell_rid*num_ref_corners_in_cell_);
};

// DANIELLOOK
int ref_element::ref_nodes_in_cell(int cell_rid, int node_rlid) const 
{
    return ref_nodes_in_cell_(node_rlid + cell_rid*num_ref_corners_in_cell_);
};

int ref_element::ref_surface_nodes_in_elem(int node_rlid) const
{
    return ref_surface_nodes_in_elem_(node_rlid);
};
    
int ref_element::ref_inside_nodes_in_elem(int node_rlid) const
{
    return ref_inside_nodes_in_elem_(node_rlid);
};
 
int ref_element::num_ref_surface_nodes_in_elem() const
{
    return num_ref_surface_nodes_in_elem_;
};

int ref_element::num_ref_inside_nodes_in_elem() const
{
    return num_ref_inside_nodes_in_elem_;
};

real_t ref_element::ref_node_positions(int node_rid, int dim) const
{
    //DANreturn ref_node_positions_[dim + node_rid*num_dim_];
    return ref_node_positions_(node_rid, dim);
};

real_t ref_element::ref_corner_surface_normals(int corner_rid, int surf_rlid, int dim) const 
{
    //DANreturn ref_corner_surf_normals_[corner_rid*num_dim_*num_dim_ + surf_rlid*num_dim_ + dim];
    return ref_corner_surf_normals_(corner_rid, surf_rlid, dim);
};

real_t ref_element::ref_corner_g_surface_weights(int corner_rid, int surf_rlid) const 
{
    //DANreturn  ref_corner_surf_g_weights_[corner_rid*num_dim_ + surf_rlid];
    return ref_corner_surf_g_weights_(corner_rid, surf_rlid);
};

real_t ref_element::ref_node_g_weights(int node_rid) const 
{
    return  ref_node_g_weights_(node_rid);
};

real_t ref_element::ref_corner_g_weights(int corner_rid) const 
{
    return  ref_corner_g_weights_(corner_rid);
};

real_t& ref_element::ref_nodal_gradient(int node_rid, int basis_id, int dim) const
{
    //return ref_nodal_gradient_[node_rid*num_dim_*num_basis_ + basis_id*num_dim_ + dim];
    return ref_nodal_gradient_(node_rid, basis_id, dim);
}

real_t& ref_element::ref_nodal_basis(int node_rid, int basis_id) const
{
    //return ref_nodal_gradient_[node_rid*num_dim_*num_basis_ + basis_id*num_dim_ + dim];
    return ref_nodal_basis_(node_rid, basis_id);
}

int& ref_element::cell_lid_in_zone(int zone_lid, int cell_lid) const
{
    return cells_in_zone_list_(zone_lid, cell_lid);
}
    
real_t ref_element::ref_cell_positions(int cell_rid, int dim) const
{
    return ref_cell_positions_(cell_rid, dim);
}
    
real_t ref_element::ref_cell_g_weights(int cell_rid) const
{
    return ref_cell_g_weights_(cell_rid);
}

int& ref_element::cell_nodes_in_elem(int cell_lid, int node_lid) const
{
    return cell_nodes_in_elem_list_(cell_lid, node_lid);
}

int ref_element::node_in_patch_in_cell(int patch_rlid, int node_lid) const
{
    int index = node_lid + patch_rlid*4;
    return node_rlid_in_patch_in_cell_[index];
}

int ref_element::patch_rlid_in_cell_neighbor(int patch_rlid) const
{
    return patch_rlid_cell_neighbor_[patch_rlid];
}

int ref_element::ref_patches_in_cell(int cell_rid, int patch_rlid) const
{
    int index = patch_rlid + cell_rid*6;
    return ref_patches_in_cell_list_(index);
}
    
real_t ref_element::cell_side_unit_normals(int side_rlid, int dim) const
{
    int index = side_rlid*3 + dim;
    return cell_side_unit_normals_[index];
}
    
real_t ref_element::ref_patch_positions(int patch_rid, int dim) const
{
    return ref_patch_positions_(patch_rid, dim);
}
    
real_t ref_element::ref_patch_g_weights(int patch_rid) const
{
    return ref_patch_g_weights_(patch_rid);
}
    
real_t ref_element::ref_patch_basis(int patch_rid, int basis_id) const
{
    return ref_patch_basis_(patch_rid, basis_id);
};
    
real_t ref_element::ref_patch_gradient(int patch_rid, int basis_id, int dim) const
{
    return ref_patch_gradient_(patch_rid, basis_id, dim);
};


real_t ref_element::ref_cell_basis(int cell_rid, int basis_id) const
{
    return ref_cell_basis_(cell_rid, basis_id);
};
    
real_t ref_element::ref_cell_gradient(int cell_rid, int basis_id, int dim) const
{
    return ref_cell_gradient_(cell_rid, basis_id, dim);
};
    
    
    
int ref_element::vert_node_map(int vert_lid)
{
    return elem_ptr->vert_node_map(vert_lid);
}




// Deconstructor
ref_element::~ref_element(){
};


/*
 .-------------------------------. 
| .----------------------------. |
| |    _____       ________    | |
| |   / ___ `.    |_   ___ `.  | |
| |  |_/___) |      | |   `. \ | |
| |   .'____.'      | |    | | | |
| |  / /____       _| |___.' / | |
| |  |_______|    |________.'  | |
| |                            | |
| '----------------------------' |
 '-------------------------------' 
*/

/*
===========================
2D Quad 4 Elements
===========================


The finite element local point numbering for a 4 node Quadrilateral is
as follows

        Eta
         ^
         |
  3------+-----2
  |      |     |
  |      |     |
  |      |     |
  |      ------+------> Xi   
  |            |
  |            |
  0------------1

*/

Quad4::Quad4() : Element2D(){
  nsurfaces = 4;
  CArray<size_t> strides(nsurfaces);
  for(int istride=0; istride < nsurfaces; istride++)
    strides(istride) = 2;
  //list of local ids to basis functions needed to interpolate throughout a given element surface
  surface_to_dof_lid = RaggedRightArray<int>(strides);
  surface_to_dof_lid(0,0) = 0;
  surface_to_dof_lid(0,1) = 1;

  surface_to_dof_lid(1,0) = 3;
  surface_to_dof_lid(1,1) = 2;

  surface_to_dof_lid(2,0) = 0;
  surface_to_dof_lid(2,1) = 3;

  surface_to_dof_lid(3,0) = 1;
  surface_to_dof_lid(3,1) = 2;

}

Quad4::~Quad4(){

}

real_t Quad4::ref_vert[Quad4::num_verts_*Quad4::num_dim_] = 
    
    {// listed as {Xi, Eta}
    -1.0, -1.0,// 0
     1.0, -1.0,// 1
     1.0,  1.0,// 2
    -1.0,  1.0,// 3
    };

const int Quad4::vert_to_node[Quad4::num_verts_] = 
    {
    0,
    2,
    6,
    8
    };


int Quad4::num_verts()
{
    return Quad4::num_verts_;
}
int Quad4::num_nodes()
{
    return Quad4::num_nodes_;
}
int Quad4::num_basis()
{
    return Quad4::num_basis_;
}


// calculate a physical position in an element for a given xi,eta
void Quad4::physical_position(
    ViewCArray <real_t> &x_point, 
    const ViewCArray <real_t> &xi_point, 
    const ViewCArray <real_t> &vertices){

    real_t basis_a[num_verts_];
    auto basis = ViewCArray <real_t> (basis_a, num_verts_);

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the shape functions from each vertex for 0 through num_verts_(xi,eta)
    for( int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){
        basis(vert_lid) = 1.0/4.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1));
    }// end for

    // calculate the position in physical space
    for (int dim = 0; dim < num_dim_; dim++) x_point(dim) = 0.0;
    
    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){
        for (int dim = 0; dim < num_dim_; dim++){
            x_point(dim) += vertices(vert_lid, dim)*basis(vert_lid);
        }// end for dim
    } // end for vert_lid

} // end of physical position functionfunction


// calculate the value for the basis at each node for a given xi,eta
void Quad4::basis(
    ViewCArray <real_t> &basis,
    const ViewCArray <real_t> &xi_point){

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);
    
    // calculate the shape functions from each vertex for 0 through num_verts_(xi,eta)
    for( int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){

        basis(vert_lid) = (1.0/4.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1));

    }// end for

}// end of quad4 basis functions 


// Partial derivative of shape functions with respect to Xi
void  Quad4::partial_xi_basis(
    ViewCArray <real_t>  &partial_xi, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);
    
    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++){
        partial_xi(vert_lid) = (1.0/4.0)
            * (ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1));
    }

}// end of partial xi funciton


// Partial derivative of shape functions with respect to Eta
void  Quad4::partial_eta_basis(
    ViewCArray <real_t> &partial_eta, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++){
        partial_eta(vert_lid) = (1.0/4.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (ref_verts(vert_lid, 1));
    }

}// end of partial eta function

int Quad4::vert_node_map(const int vert_lid){

    return vert_to_node[vert_lid];

}



/*
===========================
2D Quad 8 Elements
===========================


 The finite element local point numbering for a 8 node Quadrilateral is
 as follows

         Eta
          ^
          |
  3-------6------2
  |       |      |
  |       |      |
  |       |      |
  |       |      |
  7       +------5-----> Xi   
  |              |
  |              |
  |              |
  0------4-------1

*/

Quad8::Quad8() : Element2D(){
  nsurfaces = 4;
  CArray<size_t> strides(nsurfaces);
  for(int istride=0; istride < nsurfaces; istride++)
    strides(istride) = 3;
  //list of local ids to basis functions needed to interpolate throughout a given element surface
  surface_to_dof_lid = RaggedRightArray<int>(strides);

  surface_to_dof_lid(0,0) = 0;
  surface_to_dof_lid(0,1) = 4;
  surface_to_dof_lid(0,2) = 1;

  surface_to_dof_lid(1,0) = 3;
  surface_to_dof_lid(1,1) = 6;
  surface_to_dof_lid(1,2) = 2;

  surface_to_dof_lid(2,0) = 0;
  surface_to_dof_lid(2,1) = 7;
  surface_to_dof_lid(2,2) = 3;

  surface_to_dof_lid(3,0) = 1;
  surface_to_dof_lid(3,1) = 5;
  surface_to_dof_lid(3,2) = 2;

}

Quad8::~Quad8(){

}

real_t Quad8::ref_vert[Quad8::num_verts_*Quad8::num_dim_] = // listed as {Xi, Eta}
    {// listed as {Xi, Eta}
    -1.0, -1.0, // 0  
     1.0, -1.0, // 1
     1.0,  1.0, // 2
    -1.0,  1.0, // 3
    // midline nodes
     0.0, -1.0, // 4
     1.0,  0.0, // 5
     0.0,  1.0, // 6
    -1.0,  0.0, // 7
    };

const int Quad8::vert_to_node[Quad8::num_verts_] = 
    {
    0,
    4,
    24,
    20,
    2,
    14,
    23,
    10
    };

int Quad8::num_verts()
{
    return Quad8::num_verts_;
}
int Quad8::num_nodes()
{
    return Quad8::num_nodes_;
}
int Quad8::num_basis()
{
    return Quad8::num_basis_;
}

// calculate a physical position in an element for a given xi,eta,
void Quad8::physical_position(
    ViewCArray <real_t> &x_point, 
    const ViewCArray <real_t> &xi_point, 
    const ViewCArray <real_t> &vertices){

    real_t basis_a[num_verts_];
    auto basis = ViewCArray <real_t> (basis_a, num_verts_);

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the shape functions for node 0,1,2,3(xi,eta)
    for( int vert_lid = 0; vert_lid < 4; vert_lid++ ){
        basis(vert_lid) = (1.0/4.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (xi_point(0)*ref_verts(vert_lid, 0) 
            +  xi_point(1)*ref_verts(vert_lid, 1) - 1.0);
    } // end for vert_lid

    // calculate the shape functions for node 4,6(xi,eta)
    for( int vert_lid = 4; vert_lid <= 6; vert_lid += 2 ){
        basis(vert_lid) = (1.0/2.0)
            * (1.0 - xi_point(0)*xi_point(0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1));
    } // end for vert_lid

    // calculate the shape functions for node 5,7 (xi,eta)
    for( int vert_lid = 5; vert_lid <= 7; vert_lid += 2 ){
        basis(vert_lid) = (1.0/2.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1));
    } // end for vert_lid

    // calculate the position in physical space
    for (int dim = 0; dim < num_dim_; dim++) x_point(dim) = 0.0;

    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){
        for (int dim = 0; dim < num_dim_; dim++){
            x_point(dim) += vertices(vert_lid, dim)*basis(vert_lid);
        } // end for dim
    } // end for vert_lid

} // end of function


// calculate the value for the basis at each node for a given xi,eta
void Quad8::basis(
    ViewCArray <real_t> &basis,
    const ViewCArray <real_t> &xi_point){

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);
    
    // calculate the shape functions for node 0,1,2,3(xi,eta)
    for( int vert_lid = 0; vert_lid < 4; vert_lid++ ){
        basis(vert_lid) = (1.0/4.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (xi_point(0)*ref_verts(vert_lid, 0) 
            +  xi_point(1)*ref_verts(vert_lid, 1) - 1.0);
    } // end for vert_lid


    // calculate the shape functions for node 4,6(xi,eta)
    for( int vert_lid = 4; vert_lid <= 6; vert_lid += 2 ){
        basis(vert_lid) = (1.0/2.0)
            * (1.0 - xi_point(0)*xi_point(0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1));
    } // end for vert_lid

    // calculate the shape functions for node 5,7 (xi,eta)
    for( int vert_lid = 5; vert_lid <= 7; vert_lid += 2 ){
        basis(vert_lid) = (1.0/2.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1));

    } // end for vert_lid

}// end of quad8 basis functions


// Partial derivative of shape functions with respect to Xi
void Quad8::partial_xi_basis(
    ViewCArray <real_t>  &partial_xi, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the Xi partials for node 0,1,2,3 (xi,eta)
    for( int vert_lid = 0; vert_lid < 4; vert_lid++ ){
        partial_xi(vert_lid) = 1.0/4.0
            * (ref_verts(vert_lid, 0))
            * (1.0 + ref_verts(vert_lid, 1)*xi_point(1))
            *((2.0 * ref_verts(vert_lid, 0)*xi_point(0)) 
            + (ref_verts(vert_lid, 1)*xi_point(1)));
    } // end for vert_lid


    // calculate the Xi partials for node 4,6 (xi,eta)
    for( int vert_lid = 4; vert_lid <= 6; vert_lid += 2 ){
        partial_xi(vert_lid) = -1.0
            * (xi_point(0))
            * (1 + ref_verts(vert_lid, 1)*xi_point(1));
    } // end for vert_lid

    // calculate the Xi partials for node 5,7 (xi,eta)
    for( int vert_lid = 5; vert_lid <= 7; vert_lid += 2 ){
        partial_xi(vert_lid) = 1.0/2.0
            * (ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1));

    } // end for vert_lid

} // end partial Xi function


// Partial derivative of shape functions with respect to Eta
void Quad8::partial_eta_basis(
    ViewCArray <real_t>  &partial_eta, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the Eta partials for node 0,1,2,3 (xi,eta)
    for( int vert_lid = 0; vert_lid < 4; vert_lid++ ){
        partial_eta(vert_lid) = (1.0/4.0)
            * (1.0 + ref_verts(vert_lid, 0)*xi_point(0))
            * (ref_verts(vert_lid, 1))
            *((ref_verts(vert_lid, 0)*xi_point(0))
            + (2.0 * ref_verts(vert_lid, 1)*xi_point(1))); 
    } // end for vert_lid

    // calculate the Eta partials for node 4,6 (xi,eta)
    for( int vert_lid = 4; vert_lid <= 6; vert_lid += 2 ){
        partial_eta(vert_lid) = (1.0/2.0)
            * (1.0 - xi_point(0)*xi_point(0))
            * (ref_verts(vert_lid, 1));
   } // end for vert_lid

    // calculate the Eta partials for node 5,7 (xi,eta)
    for( int vert_lid = 5; vert_lid <= 7; vert_lid += 2 ){
        partial_eta(vert_lid) = (-1.0)
            * (1.0 + ref_verts(vert_lid, 0)*xi_point(0))
            * (xi_point(1));
    } // end for vert_lid

} // end partial Eta function

int Quad8::vert_node_map(const int vert_lid){

    return vert_to_node[vert_lid];

}


/*
===========================
2D Quad 12 Elements
===========================


The finite element local point numbering for a 8 node Quadrilateral is
as follows

         Eta
          ^
          |
  3---7------6---2
  |       |      |
  |       |      |
 11       |      10
  |       |      |
  |       +------|-----> Xi   
  |              |
  8              9
  |              |
  0----4-----5---1

*/

Quad12::Quad12() : Element2D(){
  nsurfaces = 4;
  CArray<size_t> strides(nsurfaces);
  for(int istride=0; istride < nsurfaces; istride++)
    strides(istride) = 4;
  //list of local ids to basis functions needed to interpolate throughout a given element surface
  surface_to_dof_lid = RaggedRightArray<int>(strides);
  surface_to_dof_lid(0,0) = 0;
  surface_to_dof_lid(0,1) = 4;
  surface_to_dof_lid(0,2) = 5;
  surface_to_dof_lid(0,3) = 1;

  surface_to_dof_lid(1,0) = 3;
  surface_to_dof_lid(1,1) = 7;
  surface_to_dof_lid(1,2) = 6;
  surface_to_dof_lid(1,3) = 2;

  surface_to_dof_lid(2,0) = 0;
  surface_to_dof_lid(2,1) = 8;
  surface_to_dof_lid(2,2) = 11;
  surface_to_dof_lid(2,3) = 3;

  surface_to_dof_lid(3,0) = 1;
  surface_to_dof_lid(3,1) = 9;
  surface_to_dof_lid(3,2) = 10;
  surface_to_dof_lid(3,3) = 2;

}

Quad12::~Quad12(){

}
      
real_t Quad12::ref_vert[Quad12::num_verts_*Quad12::num_dim_] = 
    {// listed as {Xi, Eta}
    //corner nodes
    -1.0, -1.0 ,// 0
     1.0, -1.0 ,// 1
     1.0,  1.0 ,// 2
    -1.0,  1.0 ,// 3
    // Eta +- 1./3.
    -1./3., -1.0 ,// 4
     1./3., -1.0 ,// 5
     1./3.,  1.0 ,// 6
    -1./3.,  1.0 ,// 7
    // Xi +- 1./3.
    -1.0, -1./3. ,// 8
     1.0, -1./3. ,// 9
     1.0,  1./3. ,// 10
    -1.0,  1./3. ,// 11
    };

const int Quad12::vert_to_node[Quad12::num_verts_] = 
    {
    0,
    6,
    48,
    42,
    2,
    4,
    46,
    44,
    14,
    20,
    34,
    28
    };


int Quad12::num_verts()
{
    return Quad12::num_verts_;
}
int Quad12::num_nodes()
{
    return Quad12::num_nodes_;
}
int Quad12::num_basis()
{
    return Quad12::num_basis_;
}



// calculate a physical position in an element for a given xi,eta,
void Quad12::physical_position(
    ViewCArray <real_t>  &x_point, 
    const ViewCArray <real_t>  &xi_point, 
    const ViewCArray <real_t>  &vertices){

    real_t basis_a[num_verts_];
    auto basis = ViewCArray <real_t> (basis_a, num_verts_);


    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the shape functions for node 0,1,2,3(xi,eta)
    for( int vert_lid = 0; vert_lid < 4; vert_lid++ ){
        basis(vert_lid) = 1.0/32.0
            * (1.0 + ref_verts(vert_lid, 0) * xi_point(0))
            * (1.0 + ref_verts(vert_lid, 1) * xi_point(1))
            * (9.0 * (xi_point(0) * xi_point(0) + xi_point(1) * xi_point(1))
            - (10.0));

    } // end for vert_lid

    // calculate the shape functions for node 4-7(xi,eta)
    for( int vert_lid = 4; vert_lid <= 7; vert_lid++ ){
        basis(vert_lid) = 9.0/32.0
            * (1.0 - xi_point(0) * xi_point(0))
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            * (1.0 + 9.0 * xi_point(0) * ref_verts(vert_lid, 0));
    } // end for vert_lid

    // calculate the shape functions for node 8-11 (xi,eta)
    for( int vert_lid = 8; vert_lid <= 11; vert_lid++ ){
        basis(vert_lid) = 9.0/32.0
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1) * xi_point(1))
            * (1.0 + 9.0 * xi_point(1) * ref_verts(vert_lid, 1));
    } // end for vert_lid

    // calculate the position in physical space
    for (int dim = 0; dim < num_dim_; dim++){
        x_point(dim) = 0.0;
    }

    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){
        for (int dim = 0; dim < num_dim_; dim++){
            x_point(dim) += vertices(vert_lid, dim)*basis(vert_lid);
        } // end for dim
    } // end for vert_lid

} // end of function


// calculate the value for the basis at each node for a given xi,eta
void Quad12::basis(
    ViewCArray <real_t>  &basis,
    const ViewCArray <real_t>  &xi_point){

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the shape functions for node 0,1,2,3(xi,eta)
    for( int vert_lid = 0; vert_lid < 4; vert_lid++ ){
        basis(vert_lid) = 1.0/32.0
            * (1.0 + ref_verts(vert_lid, 0) * xi_point(0))
            * (1.0 + ref_verts(vert_lid, 1) * xi_point(1))
            * (9.0 * (xi_point(0) * xi_point(0) + xi_point(1) * xi_point(1))
            - (10.0));

    } // end for vert_lid

    // calculate the shape functions for node 4-7(xi,eta)
    for( int vert_lid = 4; vert_lid <= 7; vert_lid++ ){
        basis(vert_lid) = 9.0/32.0
            * (1.0 - xi_point(0) * xi_point(0))
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            * (1.0 + 9.0 * xi_point(0) * ref_verts(vert_lid, 0));
    } // end for vert_lid

    // calculate the shape functions for node 8-11 (xi,eta)
    for( int vert_lid = 8; vert_lid <= 11; vert_lid++ ){
        basis(vert_lid) = 9.0/32.0
                         * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
                         * (1.0 - xi_point(1) * xi_point(1))
                         * (1.0 + 9.0 * xi_point(1) * ref_verts(vert_lid, 1));
    } // end for vert_lid

}// end of quad12 basis functions


// Partial derivative of shape functions with respect to Xi
void Quad12::partial_xi_basis(
    ViewCArray <real_t>  &partial_xi, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the Xi partials for node 0,1,2,3 (xi,eta)
    for( int vert_lid = 0; vert_lid < 4; vert_lid++ ){
        partial_xi(vert_lid) = 1.0/32.0
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            *((9.0 * ref_verts(vert_lid, 0) 
            * (xi_point(0) * xi_point(0) + xi_point(1) * xi_point(1)))
            + (18.0 * xi_point(0) * (1.0 + xi_point(0) * ref_verts(vert_lid, 0)))
            - (10.0 * ref_verts(vert_lid, 0)));
    } // end for vert_lid

    // calculate the Xi partials for node 4,5,6,7 (xi,eta)
    for( int vert_lid = 4; vert_lid < 8; vert_lid++ ){
        partial_xi(vert_lid) = (9.0/32.0) 
                              * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
                              *((9.0 * ref_verts(vert_lid, 0) 
                              * (1.0 - 3.0 * xi_point(0)*xi_point(0)))
                              - (2.0 * xi_point(0)));
    } // end for vert_lid

    // calculate the Xi partials for node 8,9,10,11 (xi,eta)
    for( int vert_lid = 8; vert_lid <= 11; vert_lid++){
        partial_xi(vert_lid) = 9.0/32.0
            * (ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1) * xi_point(1))
            * (1.0 + 9.0 * xi_point(1) * ref_verts(vert_lid, 1));
    } // end for vert_lid

} // end partial Xi function


// Partial derivative of shape functions with respect to Eta
void Quad12::partial_eta_basis(
    ViewCArray <real_t> &partial_eta, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);
    // calculate the Eta partials for node 0,1,2,3 (xi,eta)
    for( int vert_lid = 0; vert_lid < 4; vert_lid++ ){
        partial_eta(vert_lid) = 1.0/32.0
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            *((9.0 * ref_verts(vert_lid, 1) 
            * (xi_point(0) * xi_point(0) + xi_point(1) * xi_point(1)))
            + (18.0 * xi_point(1) * (1.0 + xi_point(1) * ref_verts(vert_lid, 1)))
            - (10.0 * ref_verts(vert_lid, 1)));
    } // end for vert_lid

    // calculate the Eta partials for node 4,5,6,7 (xi,eta)
    for( int vert_lid = 4; vert_lid <= 7; vert_lid++ ){
        partial_eta(vert_lid) = 9.0/32.0
            * (1.0 - xi_point(0) * xi_point(0))
            * (1.0 + 9.0 * xi_point(0) * ref_verts(vert_lid, 0))
            * (ref_verts(vert_lid, 1));
    } // end for vert_lid

    // calculate the Eta partials for node 8,9,10,11 (xi,eta)
    for( int vert_lid = 8; vert_lid <= 11; vert_lid++){
        partial_eta(vert_lid) = 9.0/32.0
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            *((9.0 * ref_verts(vert_lid, 1) * (1.0 - 3.0 * xi_point(1)*xi_point(1)))
            - (2.0 * xi_point(1)));

    } // end for vert_lid

} // end partial Eta function

int Quad12::vert_node_map(const int vert_lid){

    return vert_to_node[vert_lid];
}



/*
 ==========================
  Arbitrary Order Elements
 ==========================


  / __ \                | | \ | |
 | |  | |_   _  __ _  __| |  \| |
 | |  | | | | |/ _` |/ _` | . ` |
 | |__| | |_| | (_| | (_| | |\  |
  \___\_\\__,_|\__,_|\__,_|_| \_| 

Representative linear element for visualization
   
         Eta (j)
          ^
          |
  3--------------2
  |       |      |
  |       |      |
  |       |      |
  |       |      |
  |       +------|-----> Xi (i) 
  |              |
  |              |
  |              |
  0--------------1
*/


// Lagrange Interp in 1D, returns interpolants and derivative
// works with any nodal spacing
void QuadN::lagrange_1D(
    ViewCArray <real_t> &interp,          // interpolant
    ViewCArray <real_t> &Dinterp,         // derivative of function
    const real_t &x_point,                  // point of interest in element
    const ViewCArray <real_t> &xi_point,  // nodal positions in 1D, normally chebyshev
    const int &orderN){                     // order of element

    real_t num_a[orderN+1];
    auto num = ViewCArray <real_t> (num_a, orderN+1); // numerator of interpolant

    real_t denom_a[orderN+1];
    auto denom = ViewCArray <real_t> (denom_a, orderN+1); // denomenator of interpolant
  
    real_t q = 0.0;
   
    for(int i = 0; i < orderN + 1; i++){ // looping over the nodes
        real_t n = 1.0;         // placeholder numerator
        real_t d = 1.0;         // placeholder denominator
        real_t c = 1.0;         // placeholder value of n/d
        real_t p = 0.0;         // placeholder for derivative values
        real_t s = 1.0;
        
        for(int j = 0; j < orderN + 1; j++){  // looping over the nodes !=i
            if (j != i ){
                n = n*(x_point - xi_point(j));
                d = d*(xi_point(i) - xi_point(j));
                real_t s = 1.0;
                
                for(int N = 0; N < orderN + 1; N++){  // looping over the nodes !=i
                    if (N != j && N != i ){
                    s = s * (x_point - xi_point(N));
                    }// end if
                }//end for
                
                p += s; 
            }//end if
         
            c = n/d; // storing a single value for interpolation for node i
            q = (p/d); // storing the derivative of the interpolating function
        } // end looping over nodes != i

        // writing value to vectors for later use
        interp(i)   = c;     // Interpolant value at given point
        Dinterp(i)  = q;     // derivative of each function
    } // end loop over all nodes

} // end of Legrange_1D function


// Corners of Lagrange element for mapping
void QuadN::corners (
    ViewCArray <real_t> &lag_nodes,   // Nodes of Lagrange elements 
    ViewCArray <real_t> &lag_corner,  // corner nodes of QuadN element
    const int &orderN){                 // Element order

    /*
    This image represents the corner mapping notation of an arbitrary ordered
    Lagrange element. The corner function takes in the element order and nodal positions and
    returns a vector containing the indices of the corner in alphabetical order.

          Eta
           ^
           |
    C------+-----D
    |      |     |
    |      |     |
    |      |     |
    |      ------+------> Xi   
    |            |
    |            |
    A------------B

    */

    int num_corners = 4;
    int N = orderN + 1;      //number of nodes in each direction
    int corner_ids[num_corners];

    corner_ids[0] = 0;                      
    corner_ids[1] = N - 1.0;                 
    corner_ids[2] = (N*N) - N;         
    corner_ids[3] = (N*N)-1.0;               

    for(int corner = 0; corner < num_corners; corner++){
        for(int dim = 0; dim < num_dim; dim++){
            lag_corner(corner, dim) = lag_nodes(corner_ids[corner], dim);
        }
    }


}// end of corner mapping function


// Functions for mapping reference position to physical position for any 
// point in an arbitrary order 3D lagrange element
void QuadN::physical_position (
    ViewCArray <real_t> &x_point,             // location in real space
    const ViewCArray <real_t> &lag_nodes,     // Nodes of Lagrange elements 
    const ViewCArray <real_t> &lag_basis_2d,  // 2D basis values 
    const int &orderN){                         // order of the element

    int nodes = orderN + 1;
    int Nnodes_2d = nodes * nodes;

    for (int this_vert = 0; this_vert < Nnodes_2d; this_vert++ ){
        for (int dim = 0; dim < num_dim; dim++){
            x_point(dim) += lag_nodes(this_vert, dim)*lag_basis_2d(this_vert);
        } // end for dim
    } // end for this_vert

}// end physical position function


void QuadN::basis_partials (
    ViewCArray <real_t> &lag_nodes,       // Nodes of Lagrange elements (to be filled in)
    ViewCArray <real_t> &nodes_1d,        // Nodal spacing in 1D, any spacing is accepted
    ViewCArray <real_t> &val_1d,          // Interpolant Value in 1D
    ViewCArray <real_t> &DVal_1d,         // Derivateive of basis in 1D
    ViewCArray <real_t> &val_2d,          // for holding the interpolant in each direction
    ViewCArray <real_t> &DVal_2d,         // for holding the derivatives in each direction
    ViewCArray <real_t> &lag_basis_2d,    // 3D basis values 
    ViewCArray <real_t> &lag_partial,     // Partial of basis 
    const ViewCArray <real_t> &xi_point,  // point of interest
    const int &orderN){                     // Element order

    /*

    representative linear element for visualization

          Eta
           ^
           |
    2------+-----3
    |      |     |
    |      |     |
    |      |     |
    |      ------+------> Xi   
    |            |
    |            |
    0------------1


    */

    int N = orderN + 1;      //number of nodes in each direction
    int tot_pts = (N*N);     // total nodes in 2D

    real_t sumi = 0.0;
    real_t sumj = 0.0;

    //Setting nodes for Lagrange Elements
    for (int m = 0; m < tot_pts; m++) {

        int i, j;
        // sets up the i and j indices for the nodes of an 
        j = floor(m/N)+1; 
        i = (m+1) - N*(j-1);

        // xi direction
        lag_nodes(m, 0) = nodes_1d(i-1); 

        // eta direction
        lag_nodes(m, 1) = nodes_1d(j-1); 


        // calling function to assign nodal values for basis and derivative
        
        //evaluating Lagrange interpolants for each function at xi_point
        lagrange_1D(val_1d, DVal_1d, xi_point(0), nodes_1d, orderN);
        val_2d(m, 0)  = val_1d(i-1); 
        DVal_2d(m, 0) = DVal_1d(i-1);

        // resetting to zero
        for(int i = 0.0; i < N; i++){
            val_1d(i)  = 0.0;
            DVal_1d(i) = 0.0;
        }


        //evaluating Legrange interpolants for each function at xi_point
        lagrange_1D(val_1d, DVal_1d, xi_point(1), nodes_1d, orderN);
        val_2d(m, 1)  = val_1d(j-1); 
        DVal_2d(m, 1) = DVal_1d(j-1);

        // resetting to zero
        for(int i = 0.0; i < N; i++){
            val_1d(i)  = 0.0;
            DVal_1d(i) = 0.0;
        }
        // Assigning and storing the Basis
        lag_basis_2d(m) = val_2d(m, 0) * val_2d(m, 1);

        // Assigning and storing the partials
        lag_partial(m, 0)  = DVal_2d(m, 0) * val_2d(m, 1);
        lag_partial(m, 1)  = val_2d(m, 0) * DVal_2d(m, 1);
    } // end for 

}// end basis_partials function




/* 
 .-------------------------------. 
| .----------------------------. |
| |    ______      ________    | |
| |   / ____ `.   |_   ___ `.  | |
| |   `'  __) |     | |   `. \ | |
| |   _  |__ '.     | |    | | | |
| |  | \____) |    _| |___.' / | |
| |   \______.'   |________.'  | |
| |                            | |
| '----------------------------' |
 '------------------------------' 
*/



/*
==========================
  Hex 8
==========================

 The finite element local vertex numbering for a 8 node Hexahedral is
 as follows

         Mu (k)
         |     Eta (j)    
         |    /
         |   /
     6---+----7
    /|   |   /|
   / |   |  / |
  4--------5  |
  |  |    -|--+---> Xi (i)
  |  |     |  |
  |  2-----|--3
  | /      | /       
  |/       |/
  0----*----1
 
*/

Hex8::Hex8() : Element3D(){
  nsurfaces = 6;
  CArray<size_t> strides(nsurfaces);
  for(int istride=0; istride < nsurfaces; istride++)
    strides(istride) = 4;
  //list of local ids to basis functions needed to interpolate throughout a given element surface
  surface_to_dof_lid = RaggedRightArray<int>(strides);

  //st planes first
  surface_to_dof_lid(0,0) = 0;
  surface_to_dof_lid(0,1) = 1;
  surface_to_dof_lid(0,2) = 2;
  surface_to_dof_lid(0,3) = 3;
  
  surface_to_dof_lid(1,0) = 4;
  surface_to_dof_lid(1,1) = 5;
  surface_to_dof_lid(1,2) = 6;
  surface_to_dof_lid(1,3) = 7;
  
  //sw planes second
  surface_to_dof_lid(2,0) = 0;
  surface_to_dof_lid(2,1) = 1;
  surface_to_dof_lid(2,2) = 4;
  surface_to_dof_lid(2,3) = 5;

  surface_to_dof_lid(3,0) = 2;
  surface_to_dof_lid(3,1) = 3;
  surface_to_dof_lid(3,2) = 6;
  surface_to_dof_lid(3,3) = 7;
  
  //tw planes third
  surface_to_dof_lid(4,0) = 0;
  surface_to_dof_lid(4,1) = 2;
  surface_to_dof_lid(4,2) = 4;
  surface_to_dof_lid(4,3) = 6;

  surface_to_dof_lid(5,0) = 1;
  surface_to_dof_lid(5,1) = 3;
  surface_to_dof_lid(5,2) = 5;
  surface_to_dof_lid(5,3) = 7;

}

Hex8::~Hex8(){

}

real_t Hex8::ref_vert[Hex8::num_verts_*Hex8::num_dim_] = 
    {// listed as {Xi, Eta, Mu}
    // Bottom Nodes
    -1.0, -1.0, -1.0,// 0
    +1.0, -1.0, -1.0,// 1
    -1.0, +1.0, -1.0,// 2
    +1.0, +1.0, -1.0,// 3
    // Top Nodes
    -1.0, -1.0, +1.0,// 4
    +1.0, -1.0, +1.0,// 5
    -1.0, +1.0, +1.0,// 6
    +1.0, +1.0, +1.0 // 7
    };

const int Hex8::vert_to_node[Hex8::num_verts_] = 
    {
    0,
    2,
    6,
    8,
    18,
    20,
    24,
    24
    };

int Hex8::num_verts()
{
    return Hex8::num_verts_;
}
int Hex8::num_nodes()
{
    return Hex8::num_nodes_;
}
int Hex8::num_basis()
{
    return Hex8::num_basis_;
}


// get the physical location for a given xi_point
void Hex8::physical_position (
    ViewCArray <real_t>  &x_point, 
    const ViewCArray <real_t>  &xi_point, 
    const ViewCArray <real_t>  &vertices){

    real_t basis_a[num_verts_];
    auto basis = ViewCArray <real_t> (basis_a, num_verts_);
    
    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the shape functions from each vertex for (xi,eta,mu)
    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){
        basis(vert_lid) = 1.0/8.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

    // calculate the position in physical space
    for (int dim = 0; dim < num_dim_; dim++){
        x_point(dim) = 0.0;
    }

    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){
        for (int dim = 0; dim < num_dim_; dim++){
            x_point(dim) += vertices(vert_lid, dim)*basis(vert_lid);
        } // end for dim
    } // end for vert_lid

} // end of function


// calculate the value for the basis at each node for a given xi,eta, mu
void Hex8::basis(
    ViewCArray <real_t>  &basis,
    const ViewCArray <real_t>  &xi_point){

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the shape functions from each vertex for (xi,eta,mu)
    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){
        basis(vert_lid) = 1.0/8.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

} // end of hex8 basis functions


// calculate the partials of the shape function 
// with respect to Xi
void Hex8::partial_xi_basis(
    ViewCArray <real_t>  &partial_xi, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // std::cout << "Inside partial xi" << std::endl;
    
    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++){

        partial_xi(vert_lid) = (1.0/8.0)
            * (ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));

    } // end for vert_lid
} // end of partial Xi function


// with respect to eta
void Hex8::partial_eta_basis(
    ViewCArray <real_t> &partial_eta, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++){
        partial_eta(vert_lid) = (1.0/8.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

} //end of partial eta function 


// with repsect to mu
void Hex8::partial_mu_basis(
    ViewCArray <real_t> &partial_mu, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++){
        partial_mu(vert_lid) = (1.0/8.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (ref_verts(vert_lid, 2));
    } // end for vert_lid

} // end of partial mu function

// Map from vertex to node
inline int Hex8::vert_node_map( const int vert_lid){
    
    return vert_to_node[vert_lid];

};


inline real_t& Hex8::ref_locs(const int vert_lid, const int dim){
    
    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    return ref_verts(vert_lid, dim);
}




/*
==========================
  Hex 20
==========================

The finite element local point numbering for a 20 node Hexahedral is 
as follows

           Mu (k)
           |     Eta (j)
           |    /
           |   /

      7----14----6
     /|         /|
   15 |       13 |
   / 19       /  18
  4----12----5   |
  |   |      |   |  --> Xi (i)
  |   |      |   |
  |   3---10-|---2
 16  /      17  /
  | 11       | 9         
  |/         |/
  0-----8----1

*/

Hex20::Hex20() : Element3D(){
  nsurfaces = 6;
  CArray<size_t> strides(nsurfaces);
  for(int istride=0; istride < nsurfaces; istride++)
    strides(istride) = 8;
  //list of local ids to basis functions needed to interpolate throughout a given element surface
  surface_to_dof_lid = RaggedRightArray<int>(strides);

  //st planes first
  surface_to_dof_lid(0,0) = 0;
  surface_to_dof_lid(0,1) = 8;
  surface_to_dof_lid(0,2) = 1;
  surface_to_dof_lid(0,3) = 11;
  surface_to_dof_lid(0,4) = 9;
  surface_to_dof_lid(0,5) = 3;
  surface_to_dof_lid(0,6) = 10;
  surface_to_dof_lid(0,7) = 2;
  
  surface_to_dof_lid(1,0) = 4;
  surface_to_dof_lid(1,1) = 12;
  surface_to_dof_lid(1,2) = 5;
  surface_to_dof_lid(1,3) = 15;
  surface_to_dof_lid(1,4) = 13;
  surface_to_dof_lid(1,5) = 7;
  surface_to_dof_lid(1,6) = 14;
  surface_to_dof_lid(1,7) = 6;
  
  //sw planes second
  surface_to_dof_lid(3,0) = 0;
  surface_to_dof_lid(3,1) = 8;
  surface_to_dof_lid(3,2) = 1;
  surface_to_dof_lid(3,3) = 16;
  surface_to_dof_lid(3,4) = 17;
  surface_to_dof_lid(3,5) = 4;
  surface_to_dof_lid(3,6) = 12;
  surface_to_dof_lid(3,7) = 5;

  surface_to_dof_lid(3,0) = 3;
  surface_to_dof_lid(3,1) = 10;
  surface_to_dof_lid(3,2) = 2;
  surface_to_dof_lid(3,3) = 19;
  surface_to_dof_lid(3,4) = 18;
  surface_to_dof_lid(3,5) = 7;
  surface_to_dof_lid(3,6) = 14;
  surface_to_dof_lid(3,7) = 6;
  
  //tw planes third
  surface_to_dof_lid(4,0) = 0;
  surface_to_dof_lid(4,1) = 11;
  surface_to_dof_lid(4,2) = 3;
  surface_to_dof_lid(4,3) = 16;
  surface_to_dof_lid(4,4) = 19;
  surface_to_dof_lid(4,5) = 4;
  surface_to_dof_lid(4,6) = 15;
  surface_to_dof_lid(4,7) = 7;

  surface_to_dof_lid(5,0) = 1;
  surface_to_dof_lid(5,1) = 9;
  surface_to_dof_lid(5,2) = 2;
  surface_to_dof_lid(5,3) = 17;
  surface_to_dof_lid(5,4) = 18;
  surface_to_dof_lid(5,5) = 5;
  surface_to_dof_lid(5,6) = 13;
  surface_to_dof_lid(5,7) = 6;

}

Hex20::~Hex20(){

}

real_t Hex20::ref_vert[Hex20::num_verts_*Hex20::num_dim_] = // listed as {Xi, Eta, Mu}
    // new indices for right hand coordinates
    {
    // bottom corners
    -1.0, -1.0, -1.0,// 0
    +1.0, -1.0, -1.0,// 1
    +1.0, +1.0, -1.0,// 2
    -1.0, +1.0, -1.0,// 3
    // top corners
    -1.0, -1.0, +1.0,// 4
    +1.0, -1.0, +1.0,// 5
    +1.0, +1.0, +1.0,// 6
    -1.0, +1.0, +1.0,// 7
    // bottom edges
     0.0, -1.0, -1.0,// 8
    +1.0,  0.0, -1.0,// 9
     0.0, +1.0, -1.0,// 10
    -1.0,  0.0, -1.0,// 11
    // top edges
     0.0, -1.0, +1.0,// 12
    +1.0,  0.0, +1.0,// 13
     0.0, +1.0, +1.0,// 14
    -1.0,  0.0, +1.0,// 15
    // middle edges
    -1.0, -1.0,  0.0,// 16
    +1.0, -1.0,  0.0,// 17
    +1.0, +1.0,  0.0,// 18
    -1.0, +1.0,  0.0// 19
    };

const int Hex20::vert_to_node[Hex20::num_verts_] = 
    {
    0,
    4,
    24,
    20,
    100,
    104,
    124,
    120,
    2,
    14,
    22,
    10,
    102,
    114,
    122,
    110,
    50,
    54,
    74,
    70
    };

int Hex20::num_verts()
{
    return Hex20::num_verts_;
}
int Hex20::num_nodes()
{
    return Hex20::num_nodes_;
}
int Hex20::num_basis()
{
    return Hex20::num_basis_;
}

// get the physical location for a given xi_point
void Hex20::physical_position (
    ViewCArray <real_t>  &x_point, 
    const ViewCArray <real_t>  &xi_point, 
    const ViewCArray <real_t>  &vertices){

    real_t basis_a[num_verts_];
    auto basis = ViewCArray <real_t> (basis_a, num_verts_);
    
    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the 8 corner shape functions for (xi,eta,mu)
    for (int vert_lid=0; vert_lid<8; vert_lid++){
        basis(vert_lid) = 1.0/8.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2))
            * (xi_point(0)*ref_verts(vert_lid, 0)
            +  xi_point(1)*ref_verts(vert_lid, 1)
            +  xi_point(2)*ref_verts(vert_lid, 2) - 2.0);
    } // end for vert_lid

    // calculate the i=0 edge shape functions pts=[8,10,12,14]
    for (int vert_lid = 8; vert_lid <= 14; vert_lid += 2){
        basis(vert_lid) = 1.0/4.0
            * (1.0 - xi_point(0)*xi_point(0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

    // calculate the k=0 edge shape functions pts=[16,17,18,19]
    for (int vert_lid = 16; vert_lid <= 19; vert_lid++){
        basis(vert_lid) = 1.0/4.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 - xi_point(2)*xi_point(2));

   } // end for vert_lid

   // calculate the j=0 edge shape functions pts=[9,11,15,13]
   for (int vert_lid = 9; vert_lid <= 15; vert_lid += 2){
        basis(vert_lid) = 1.0/4.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

    // calculate the position in physical space
    for (int dim = 0; dim < num_dim_; dim++) x_point(dim) = 0.0;

    for (int dim = 0; dim < num_dim_; dim++){
        for (int vert_lid = 0; vert_lid < num_verts_; vert_lid++ ){
            x_point(dim) += vertices(vert_lid, dim)*basis(vert_lid);
        }   
    } // end for dim

} // end of physical position function


// calculate the value for the basis at each node for a given xi,eta, mu
void Hex20::basis(
    ViewCArray <real_t>  &basis,
    const ViewCArray <real_t>  &xi_point){

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the 8 corner shape functions for (xi,eta,mu)
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        basis(vert_lid) = 1.0/8.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2))
            * (xi_point(0)*ref_verts(vert_lid, 0)
            +  xi_point(1)*ref_verts(vert_lid, 1)
            +  xi_point(2)*ref_verts(vert_lid, 2) - 2.0);
    } // end for vert_lid

    // calculate the i=0 edge shape functions pts=[8,10,12,14]
    for (int vert_lid = 8; vert_lid <= 14; vert_lid += 2){
        basis(vert_lid) = 1.0/4.0
            * (1.0 - xi_point(0)*xi_point(0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

    // calculate the k=0 edge shape functions pts=[16,17,18,19]
    for (int vert_lid = 16; vert_lid <= 19; vert_lid++){
        basis(vert_lid) = 1.0/4.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 - xi_point(2)*xi_point(2)); 
    } // end for vert_lid

    // calculate the j=0 edge shape functions pts=[9,11,15,13]
    for (int vert_lid = 9; vert_lid <= 15; vert_lid += 2){
        basis(vert_lid) = 1.0/4.0
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));           
    } // end for vert_lid

} // end of hex20 basis functions


// Calculate the partials of the shape functions
// with respect to Xi
void  Hex20::partial_xi_basis(
    ViewCArray <real_t>  &partial_xi, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // For 8 Corner shape functions pts=[0,1,2,3,4,5,6,7]
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        partial_xi(vert_lid) = (1.0/8.0) 
            * (ref_verts(vert_lid, 0))
            * (1.0 + (xi_point(1)*ref_verts(vert_lid, 1)))
            * (1.0 + (xi_point(2)*ref_verts(vert_lid, 2)))
            * (2.0 * (xi_point(0)*ref_verts(vert_lid, 0))
            + xi_point(1)*ref_verts(vert_lid, 1)
            + xi_point(2)*ref_verts(vert_lid, 2) - 1.0);  
    } // end for vert_lid

    // for the i=0 edge shape functions pts=[8,10,12,14]
    for (int vert_lid = 8; vert_lid <= 14; vert_lid += 2){
        partial_xi(vert_lid) = (-1.0/2.0)
            * (xi_point(0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

    // for the k=0 shape functions pts=[9,11,13,15]
    for (int vert_lid = 9; vert_lid <= 15; vert_lid += 2){
        partial_xi(vert_lid) = (1.0/4.0)
            * (ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 - xi_point(2)*xi_point(2));
    } // end for vert_lid


    // for the j=0 edge shape functions pts=[16,17,18,19]
    for (int vert_lid = 16; vert_lid <= 19; vert_lid++){
        partial_xi(vert_lid) = (1.0/4.0)
            * (ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

} // end of partial Xi function


// with respect to Eta
void Hex20::partial_eta_basis(
    ViewCArray <real_t> &partial_eta, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // For 8 Corner shape functions pts=[0,1,2,3,4,5,6,7]
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        partial_eta(vert_lid) = (1.0/8.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2))
            * (xi_point(0)*ref_verts(vert_lid, 0)
            +  2.0 * xi_point(1)*ref_verts(vert_lid, 1)
            + xi_point(2)*ref_verts(vert_lid, 2) - 1.0);
    } // end for vert_lid

    // for the i=0 edge shape functions pts=[8,10,12,14]
    for (int vert_lid = 8; vert_lid <= 14; vert_lid += 2){
        partial_eta(vert_lid) = (1.0/4.0)
            * (1.0 - (xi_point(0)*xi_point(0)))
            * (ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

    // for the j=0 shape functions pts=[9,11,13,15]
    for (int vert_lid = 9; vert_lid <= 15; vert_lid += 2){
        partial_eta(vert_lid) = (-1.0/2.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (xi_point(1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

    // for the k=0 edge shape functions pts=[16,17,18,19]
    for (int vert_lid = 16; vert_lid <= 19; vert_lid++){
        partial_eta(vert_lid) = (1.0/4.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (ref_verts(vert_lid, 1))
            * (1.0 - (xi_point(2)*xi_point(2)));
    } // end for vert_lid

} // end of partial Eta function


// with repsect to mu
void Hex20::partial_mu_basis(
    ViewCArray <real_t> &partial_mu, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // For 8 Corner shape functions pts=[0,1,2,3,4,5,6,7]
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        partial_mu(vert_lid) = (1.0/8.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (ref_verts(vert_lid, 2))
            * ((xi_point(0)*ref_verts(vert_lid, 0))
            + (xi_point(1)*ref_verts(vert_lid, 1))
            + (2.0 * xi_point(2)*ref_verts(vert_lid, 2)) - 1.0);
    } // end for vert_lid

    // for the i=0 edge shape functions pts=[8,10,12,14]
    for (int vert_lid = 8; vert_lid <= 14; vert_lid += 2){
        partial_mu(vert_lid) = (1.0/4.0)
            * (1.0 - (xi_point(0)*xi_point(0))) 
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (ref_verts(vert_lid, 2));
    }

    // for the j=0 shape functions pts=[9,11,13,15]
    for (int vert_lid = 9; vert_lid <= 15; vert_lid += 2){
        partial_mu(vert_lid) = (1.0/4.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1))
            * (ref_verts(vert_lid, 2));
    } // end for vert_lid

    // for the j=0 edge shape functions pts=[16,17,18,19]
    for (int vert_lid = 16; vert_lid <= 19; vert_lid++){
        partial_mu(vert_lid) = (-1.0/2.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (xi_point(2));
    } // end for vert_lid

} // end of partial Mu function



// Map from vertex to node
inline int Hex20::vert_node_map( const int vert_lid){

    return vert_to_node[vert_lid];
};


inline real_t& Hex20::ref_locs(const int vert_lid, const int dim){
    
    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    return ref_verts(vert_lid, dim);
}

/* 
==========================
  Hex 32
==========================

The finite element local point numbering for a 32 node Hexahedral is 
shown below


               Mu (k)
                ^         Eta (j)
                |        /
                |       /
                       /
        7----23------22----6
       /|                 /|
     15 |               14 |
     /  |               /  |
   12  31             13   30 
   /    |             /    |
  4-----20-----21----5     |
  |     |            |     |   ----> Xi (i)
  |    27            |     26  
  |     |            |     |
 28     |           29     |
  |     3----19------|18---2
  |    /             |    /
  |  11              |   10
 24  /              25  /
  | 8                | 9         
  |/                 |/
  0----16------17----1
*/


Hex32::Hex32() : Element3D(){
  nsurfaces = 6;
  CArray<size_t> strides(nsurfaces);
  for(int istride=0; istride < nsurfaces; istride++)
    strides(istride) = 12;
  //list of local ids to basis functions needed to interpolate throughout a given element surface
  surface_to_dof_lid = RaggedRightArray<int>(strides);

  //st planes first
  surface_to_dof_lid(0,0) = 0;
  surface_to_dof_lid(0,1) = 16;
  surface_to_dof_lid(0,2) = 17;
  surface_to_dof_lid(0,3) = 1;
  surface_to_dof_lid(0,4) = 8;
  surface_to_dof_lid(0,5) = 9;
  surface_to_dof_lid(0,6) = 11;
  surface_to_dof_lid(0,7) = 10;
  surface_to_dof_lid(0,8) = 3;
  surface_to_dof_lid(0,9) = 19;
  surface_to_dof_lid(0,10) = 18;
  surface_to_dof_lid(0,11) = 2;
  
  surface_to_dof_lid(1,0) = 4;
  surface_to_dof_lid(1,1) = 20;
  surface_to_dof_lid(1,2) = 21;
  surface_to_dof_lid(1,3) = 5;
  surface_to_dof_lid(1,4) = 12;
  surface_to_dof_lid(1,5) = 13;
  surface_to_dof_lid(1,6) = 15;
  surface_to_dof_lid(1,7) = 14;
  surface_to_dof_lid(1,8) = 7;
  surface_to_dof_lid(1,9) = 23;
  surface_to_dof_lid(1,10) = 22;
  surface_to_dof_lid(1,11) = 6;
  
  //sw planes second
  surface_to_dof_lid(2,0) = 0;
  surface_to_dof_lid(2,1) = 16;
  surface_to_dof_lid(2,2) = 17;
  surface_to_dof_lid(2,3) = 1;
  surface_to_dof_lid(2,4) = 24;
  surface_to_dof_lid(2,5) = 25;
  surface_to_dof_lid(2,6) = 28;
  surface_to_dof_lid(2,7) = 29;
  surface_to_dof_lid(2,8) = 4;
  surface_to_dof_lid(2,9) = 20;
  surface_to_dof_lid(2,10) = 21;
  surface_to_dof_lid(2,11) = 25;

  surface_to_dof_lid(3,0) = 3;
  surface_to_dof_lid(3,1) = 19;
  surface_to_dof_lid(3,2) = 18;
  surface_to_dof_lid(3,3) = 2;
  surface_to_dof_lid(3,4) = 27;
  surface_to_dof_lid(3,5) = 26;
  surface_to_dof_lid(3,6) = 31;
  surface_to_dof_lid(3,7) = 30;
  surface_to_dof_lid(3,8) = 7;
  surface_to_dof_lid(3,9) = 23;
  surface_to_dof_lid(3,10) = 22;
  surface_to_dof_lid(3,11) = 6;
  
  //tw planes third
  surface_to_dof_lid(4,0) = 0;
  surface_to_dof_lid(4,1) = 8;
  surface_to_dof_lid(4,2) = 11;
  surface_to_dof_lid(4,3) = 3;
  surface_to_dof_lid(4,4) = 24;
  surface_to_dof_lid(4,5) = 27;
  surface_to_dof_lid(4,6) = 28;
  surface_to_dof_lid(4,7) = 31;
  surface_to_dof_lid(4,8) = 4;
  surface_to_dof_lid(4,9) = 12;
  surface_to_dof_lid(4,10) = 15;
  surface_to_dof_lid(4,11) = 7;

  surface_to_dof_lid(5,0) = 1;
  surface_to_dof_lid(5,1) = 9;
  surface_to_dof_lid(5,2) = 10;
  surface_to_dof_lid(5,3) = 2;
  surface_to_dof_lid(5,4) = 25;
  surface_to_dof_lid(5,5) = 26;
  surface_to_dof_lid(5,6) = 29;
  surface_to_dof_lid(5,7) = 30;
  surface_to_dof_lid(5,8) = 5;
  surface_to_dof_lid(5,9) = 13;
  surface_to_dof_lid(5,10) = 14;
  surface_to_dof_lid(5,11) = 6;

}

Hex32::~Hex32(){

}

real_t Hex32::ref_vert[Hex32::num_verts_*Hex32::num_dim_] = // listed as {Xi, Eta, Mu}
    {
    -1.0, -1.0, -1.0,// 0
    +1.0, -1.0, -1.0,// 1
    +1.0, +1.0, -1.0,// 2
    -1.0, +1.0, -1.0,// 3
    -1.0, -1.0, +1.0,// 4
    +1.0, -1.0, +1.0,// 5
    +1.0, +1.0, +1.0,// 6
    -1.0, +1.0, +1.0,// 7
    // Xi/Mu = +- 1/3
    -1.0, -1./3., -1.0,// 8
     1.0, -1./3., -1.0,// 9
     1.0, +1./3., -1.0,// 10
    -1.0, +1./3., -1.0,// 11
    -1.0, -1./3., +1.0,// 12
     1.0, -1./3., +1.0,// 13
     1.0, +1./3., +1.0,// 14
    -1.0, +1./3., +1.0,// 15
    // Eta/Mu = +- 1/3
    -1./3., -1.0, -1.0,// 16
     1./3., -1.0, -1.0,// 17
     1./3., +1.0, -1.0,// 18
    -1./3., +1.0, -1.0,// 19
    -1./3., -1.0,  1.0,// 20
     1./3., -1.0,  1.0,// 21
     1./3., +1.0,  1.0,// 22
    -1./3., +1.0,  1.0,// 23
    // Xi/Eta = +- 1/3
    -1.0, -1.0, -1./3.,// 24
     1.0, -1.0, -1./3.,// 25
     1.0,  1.0, -1./3.,// 26
    -1.0,  1.0, -1./3.,// 27
    -1.0, -1.0,  1./3.,// 28
     1.0, -1.0,  1./3.,// 29
     1.0,  1.0,  1./3.,// 30
    -1.0,  1.0,  1./3.,// 31
    };

const int Hex32::vert_to_node[Hex32::num_verts_] = 
    {
    0,
    6,
    48,
    42,
    294,
    300,
    342,
    336,
    14,
    20,
    32,
    28,
    308,
    314,
    328,
    322,
    2,
    4,
    46,
    44,
    296,
    298,
    340,
    338,
    98,
    104,
    146,
    140,
    196,
    202,
    244,
    298
    };

int Hex32::num_verts()
{
    return Hex32::num_verts_;
}
int Hex32::num_nodes()
{
    return Hex32::num_nodes_;
}
int Hex32::num_basis()
{
    return Hex32::num_basis_;
}


// get the physical location for a given xi_point
void Hex32::physical_position (
    ViewCArray <real_t>  &x_point, 
    const ViewCArray <real_t>  &xi_point, 
    const ViewCArray <real_t>  &vertices){

    real_t basis_a[num_verts_];
    auto basis = ViewCArray <real_t> (basis_a, num_verts_);
    
    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the 8 corner shape functions for (xi,eta,mu)
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        basis(vert_lid) = (1.0/64.0) 
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2))
            * (9.0 * xi_point(0)*xi_point(0)
            +  9.0 * xi_point(1)*xi_point(1)
            +  9.0 * xi_point(2)*xi_point(2) - 19.0);  
    } // end for vert_lid

    // calculate the edge shape functions for pts=[8-15]
    for (int vert_lid = 8; vert_lid <= 15; vert_lid++){
        basis(vert_lid) = (9.0/64.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1))
            * (1.0 + 9.0 * xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid
    
    // calculate the edge shape functions for pts=[16-23]
    for (int vert_lid = 16; vert_lid <= 23; vert_lid++){
        basis(vert_lid) = (9.0/64.0)
            * (1.0 - xi_point(0)*xi_point(0))
            * (1.0 + 9.0 * xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2)); 
    } // end for vert_lid

    // calculate the edge shape functions for pts=[24-31]
    for (int vert_lid = 24; vert_lid <= 31; vert_lid++){
        basis(vert_lid) = (9.0/64.0) 
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + 9.0 * xi_point(2)*ref_verts(vert_lid, 2))
            * (1.0 - xi_point(2)*xi_point(2)); 
    } // end for vert_lid


    // calculate the position in physical space
    for (int dim = 0; dim < num_dim_; dim++){
        x_point(dim) = 0.0;
    }

    for (int vert_lid = 0; vert_lid <= num_verts_; vert_lid++ ){
        //std::cout << "Vert :" << vert_lid << std::endl;
        for (int dim = 0; dim < num_dim_; dim++){
            x_point(dim) += vertices(vert_lid, dim)*basis(vert_lid);
        }
    }

} // end of physical position function


void Hex32::basis(
    ViewCArray <real_t>  &basis,
    const ViewCArray <real_t>  &xi_point){

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the 8 corner shape functions for (xi,eta,mu)
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        basis(vert_lid) = (1.0/64.0) 
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2))
            * (9.0 * xi_point(0)*xi_point(0)
            +  9.0 * xi_point(1)*xi_point(1)
            +  9.0 * xi_point(2)*xi_point(2) - 19.0);  
    } // end for vert_lid

    // calculate the edge shape functions for pts=[8-15]
    for (int vert_lid = 8; vert_lid <= 15; vert_lid++){
        basis(vert_lid) = (9.0/64.0)
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1)*xi_point(1))
            * (1.0 + 9.0 * xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2));
    } // end for vert_lid

    // calculate the edge shape functions for pts=[16-23]
    for (int vert_lid = 16; vert_lid <= 23; vert_lid++){
        basis(vert_lid) = (9.0/64.0)
            * (1.0 - xi_point(0)*xi_point(0))
            * (1.0 + 9.0 * xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2)*ref_verts(vert_lid, 2)); 
    } // end for vert_lid

    // calculate the edge shape functions for pts=[24-31]
    for (int vert_lid = 24; vert_lid < num_verts_; vert_lid++){
        basis(vert_lid) = (9.0/64.0) 
            * (1.0 + xi_point(0)*ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1)*ref_verts(vert_lid, 1))
            * (1.0 + 9.0 * xi_point(2)*ref_verts(vert_lid, 2))
            * (1.0 - xi_point(2)*xi_point(2)); 
    } // end for vert_lid

} // end of hex20 basis functions

// Calculate the partials of the shape functions
// with respect to Xi
void  Hex32::partial_xi_basis(
    ViewCArray <real_t>  &partial_xi, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the 8 corner partial wrt Xi 
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        partial_xi(vert_lid) = (1.0/64.0) 
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2) * ref_verts(vert_lid, 2))
            *((9.0 * (ref_verts(vert_lid, 0))
            * (xi_point(0)*xi_point(0) +  xi_point(1)*xi_point(1) + xi_point(2)*xi_point(2)))
            + (18.0 * xi_point(0) * (1.0 + xi_point(0)*ref_verts(vert_lid, 0)))
            - (19.0 * ref_verts(vert_lid, 0)));
    } // end for vert_lid

    // calculate the edge partial wrt Xi for pts=[8-15]
    for (int vert_lid = 8; vert_lid <= 15; vert_lid++){
        partial_xi(vert_lid) = (9.0/64.0) 
            * (ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            * (1.0 + 9.0 * xi_point(2) * ref_verts(vert_lid, 2))
            * (1.0 - xi_point(2) * xi_point(2));
    } // end for vert_lid

    // calculate the edge partial wrt Xi for pts=[16-23]
    for (int vert_lid = 16; vert_lid <= 23; vert_lid++){
        partial_xi(vert_lid) = (9.0/64.0) 
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2) * ref_verts(vert_lid, 2))
            * (9.0 * ref_verts(vert_lid, 0) * (1.0 - 3.0 * xi_point(0) * xi_point(0))
            - (2 * xi_point(0)));
    } // end for vert_lid

    // calculate the edge partial wrt Xi for pts=[24-31]
    for (int vert_lid = 24; vert_lid <= 31; vert_lid++){
        partial_xi(vert_lid) = (9.0/64.0) 
            * (ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1) * xi_point(1))
            * (1.0 + 9.0 * xi_point(1) * ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2) * ref_verts(vert_lid, 2));
    } // end for vert_lid

} // end of partial Xi function


// with respect to Eta
// functions for [18-15] and [24-31] were switched 
void Hex32::partial_eta_basis(
    ViewCArray <real_t> &partial_eta, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the 8 corner partial wrt Eta 
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        partial_eta(vert_lid) = (1.0/64.0) 
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            * (1.0 + xi_point(2) * ref_verts(vert_lid, 2))
            *((9.0 * ref_verts(vert_lid, 1)
            * (xi_point(0)*xi_point(0) 
            +  xi_point(1)*xi_point(1)
            +  xi_point(2)*xi_point(2)))
            + (18.0 * xi_point(1) * (1.0 + xi_point(1)*ref_verts(vert_lid, 1)))
            - (19.0 * ref_verts(vert_lid, 1)));
    } // end for vert_lid

    // calculate the edge partial wrt Eta for pts=[8-15]
    for (int vert_lid = 8; vert_lid <= 15; vert_lid++){
        partial_eta(vert_lid) = (9.0/64.0) 
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            * (1.0 + xi_point(2) * ref_verts(vert_lid, 2))
            *((9.0 * ref_verts(vert_lid, 1) * (1.0 - 3.0 * xi_point(1) * xi_point(1)))
            - (2.0 * xi_point(1)));
    } // end for vert_lid

    // calculate the edge partial wrt Eta for pts=[16-23]
    for (int vert_lid = 16; vert_lid <= 23; vert_lid++){
        partial_eta(vert_lid) = (9.0/64.0) 
            * (1.0 - xi_point(0) * xi_point(0))
            * (1.0 + 9.0 * xi_point(0) * ref_verts(vert_lid, 0))
            * (ref_verts(vert_lid, 1))
            * (1.0 + xi_point(2) * ref_verts(vert_lid, 2));
    } // end for vert_lid

    // calculate the edge partial wrt Eta for pts=[24-31]
    for (int vert_lid = 24; vert_lid <= 31; vert_lid++){
        partial_eta(vert_lid) = (9.0/64.0) 
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            * (ref_verts(vert_lid, 1))
            * (1.0 + 9.0 * xi_point(2) * ref_verts(vert_lid, 2))
            * (1.0 - xi_point(2) * xi_point(2));
    } // end for vert_lid

} // end of partial Eta function


// with repsect to mu
// functions for [18-15] and [24-31] were switched 
void Hex32::partial_mu_basis(
    ViewCArray <real_t> &partial_mu, 
    const ViewCArray <real_t>  &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    // calculate the 8 corner partial wrt Mu 
    for (int vert_lid = 0; vert_lid < 8; vert_lid++){
        partial_mu(vert_lid) = (1.0/64.0)
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            *((9.0 * (ref_verts(vert_lid, 2))
            * (xi_point(0)*xi_point(0) 
            +  xi_point(1)*xi_point(1)
            +  xi_point(2)*xi_point(2))) 
            + (18.0 * xi_point(2) * (1 + xi_point(2)*ref_verts(vert_lid, 2)))
            - (19.0 * ref_verts(vert_lid, 2)));
    } // end for vert_lid

    // calculate the edge partial wrt Mu for pts=[8-15]
    for (int vert_lid = 8; vert_lid <= 15; vert_lid++){
        partial_mu(vert_lid) = (9.0/64.0) 
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            * (1.0 - xi_point(1) * xi_point(1))
            * (1.0 + 9.0 * xi_point(1) * ref_verts(vert_lid, 1))
            * (ref_verts(vert_lid, 2));

    } // end for vert_lid

    // calculate the edge partial wrt Mu for pts=[16-23]
    for (int vert_lid = 16; vert_lid <= 23; vert_lid++){
        partial_mu(vert_lid) = (9.0/64.0) 
            * (1.0 - xi_point(0) * xi_point(0))
            * (1.0 + 9.0 * xi_point(0) * ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            * (ref_verts(vert_lid, 2));
    } // end for vert_lid

    // calculate the edge partial wrt Mu for pts=[24-31]
    for (int vert_lid = 24; vert_lid <= 31; vert_lid++){
        partial_mu(vert_lid) = (9.0/64.0) 
            * (1.0 + xi_point(0) * ref_verts(vert_lid, 0))
            * (1.0 + xi_point(1) * ref_verts(vert_lid, 1))
            *((9.0 * ref_verts(vert_lid, 2) 
            * (1.0 -  3.0 * xi_point(2) * xi_point(2)))
            - (2.0 * xi_point(2)));
    } // end for vert_lid

} // end of partial Mu function


// Map from vertex to node
int Hex32::vert_node_map( const int vert_lid){

    return vert_to_node[vert_lid];
};


inline real_t& Hex32::ref_locs(const int vert_lid, const int dim){
    
    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts_, num_dim_);

    return ref_verts(vert_lid, dim);
}



/*
 _   _           _   _ 
| | | | _____  _| \ | |
| |_| |/ _ \ \/ /  \| |
|  _  |  __/>  <| |\  |
|_| |_|\___/_/\_\_| \_|
                       
representative linear element for visualization
   
           j
           |     k    
           |    /
           |   /
       6---+----7
      /|   |   /|
     / |   |  / |
    4--------5  |
    |  |    -|--+---> i
    |  |     |  |
    |  2-----|--3
    | /      | /       
    |/       |/
    0--------1
    

*/


    void HexN::setup_HexN(int elem_order){

        

        if(elem_order == 0){

            num_nodes_1d_ = 2;
            num_nodes_ = pow(num_nodes_1d_, 3);

            HexN_Nodes_1d_ = CArray <real_t> (num_nodes_);
            HexN_Nodes_ = CArray <real_t> (num_nodes_, 3);


            // Vertices
            num_verts_1d_ = 2;
            num_verts_ = pow(num_verts_1d_, 3);
            num_basis_ = pow(num_verts_1d_, 3);
            
            HexN_Verts_1d_ = CArray <real_t> (num_verts_);
            HexN_Verts_ = CArray <real_t> (num_verts_, 3);


            Vert_Node_map_ = CArray <size_t> (num_verts_);

            order_ = elem_order+1;


        }


        else{
            
            // Nodes
            num_nodes_1d_ = 2 * elem_order + 1;
            num_nodes_ = pow(num_nodes_1d_, 3);

            HexN_Nodes_1d_ = CArray <real_t> (num_nodes_);
            HexN_Nodes_ = CArray <real_t> (num_nodes_, 3);


            // Vertices
            num_verts_1d_ = elem_order + 1;
            num_verts_ = pow(num_verts_1d_, 3);
            num_basis_ = pow(num_verts_1d_, 3);
            
            HexN_Verts_1d_ = CArray <real_t> (num_verts_);
            HexN_Verts_ = CArray <real_t> (num_verts_, 3);


            Vert_Node_map_ = CArray <size_t> (num_verts_);

            order_ = elem_order;

        }
        
        create_lobatto_nodes(elem_order);


        // Set the vertex to node map (every other node)
        if(elem_order == 0){

            int vert_rid = 0;
            for(int k = 0; k < num_nodes_1d_; k++){
                for(int j = 0; j < num_nodes_1d_; j++){
                    for(int i = 0; i < num_nodes_1d_; i++){

                        int node_id = node_rid(i, j, k);
                        
                        Vert_Node_map_(vert_rid) = node_id;

                        vert_rid++;                        
                    }   
                }
            }


        }


        if (elem_order >= 1){

            int vert_rid = 0;
            for(int k = 0; k < num_nodes_1d_; k=k+2){
                for(int j = 0; j < num_nodes_1d_; j=j+2){
                    for(int i = 0; i < num_nodes_1d_; i=i+2){

                        int node_id = node_rid(i, j, k);
                        Vert_Node_map_(vert_rid) = node_id;
                        vert_rid++;
                    }   
                }
            }
        }
    
    }

    int HexN::num_verts()
    {
        return HexN::num_verts_;
    };
    int HexN::num_nodes()
    {
        return HexN::num_nodes_;
    };
    int HexN::num_basis()
    {
        return HexN::num_basis_;
    };

    real_t& HexN::node_coords(int node_rlid, int this_dim)
    {
        return HexN_Nodes_(node_rlid, this_dim);
    };


    int HexN::vert_node_map(int vert_rid) const
    {
        return Vert_Node_map_(vert_rid);
    }


    int HexN::node_rid(int i, int j, int k) const 
    {
        return i + j*num_nodes_1d_ + k*num_nodes_1d_*num_nodes_1d_;
    };

    int HexN::vert_rid(int i, int j, int k) const 
    {
        return i + j*num_verts_1d_ + k*num_verts_1d_*num_verts_1d_;
    };

    void HexN::basis(CArray <real_t> &basis, CArray <real_t> &point)
    {

        auto val_1d = CArray <real_t> (num_verts_1d_);
        auto val_3d = CArray <real_t> (num_verts_1d_, 3);

        // Calculate 1D basis for the X coordinate of the point
        lagrange_basis_1D(val_1d, point(0));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            val_3d(i, 0) = val_1d(i);
            val_1d(i) = 0.0;
        }

        // Calculate 1D basis for the Y coordinate of the point
        lagrange_basis_1D(val_1d, point(1));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            val_3d(i, 1) = val_1d(i);
            val_1d(i) = 0.0;
        }

        // Calculate 1D basis for the Z coordinate of the point
        lagrange_basis_1D(val_1d, point(2));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            val_3d(i, 2) = val_1d(i);
            val_1d(i) = 0.0;
        }
        
        // Multiply the i, j, k components of the basis from each node
        // to get the tensor product basis for the node
        for(int k = 0; k < num_verts_1d_; k++){
            for(int j = 0; j < num_verts_1d_; j++){
                for(int i = 0; i < num_verts_1d_; i++){

                    int vert_rlid = vert_rid(i,j,k);
                    basis(vert_rlid) = val_3d(i, 0)*val_3d(j, 1)*val_3d(k, 2);
                }
            }
        }
    };


    void HexN::partial_xi_basis(CArray <real_t> &partial_xi, CArray <real_t> &point)
    {


        auto val_1d = CArray <real_t> (num_verts_1d_);
        auto val_3d = CArray <real_t> (num_verts_1d_, 3);

        auto Dval_1d = CArray <real_t> (num_verts_1d_);
        auto Dval_3d = CArray <real_t> (num_verts_1d_, 3);

        // Calculate 1D partial w.r.t. xi for the X coordinate of the point
        lagrange_derivative_1D(Dval_1d, point(0));


        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            Dval_3d(i,0) = Dval_1d(i);
            Dval_1d(i) = 0.0;
        }


        // Calculate 1D basis for the Y coordinate of the point
        lagrange_basis_1D(val_1d, point(1));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            val_3d(i,1) = val_1d(i);
            val_1d(i) = 0.0;
        }


        // Calculate 1D basis for the Z coordinate of the point
        lagrange_basis_1D(val_1d, point(2));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            val_3d(i,2) = val_1d(i);
            val_1d(i) = 0.0;
        }

        // Multiply the i, j, k components of the basis and partial_xi from each node
        // to get the tensor product partial derivatives of the basis at each node
        for(int k = 0; k < num_verts_1d_; k++){
            for(int j = 0; j < num_verts_1d_; j++){
                for(int i = 0; i < num_verts_1d_; i++){
                    
                    int vert_rlid = vert_rid(i,j,k);

                    // Partial w.r.t xi
                    partial_xi(vert_rlid) = Dval_3d(i, 0)*val_3d(j, 1)*val_3d(k, 2);

                }
            }
        }
    };


    void HexN::partial_eta_basis(CArray <real_t> &partial_eta, CArray <real_t> &point)
    {   

        auto val_1d = CArray <real_t> (num_verts_1d_);
        auto val_3d = CArray <real_t> (num_verts_1d_, 3);

        auto Dval_1d = CArray <real_t> (num_verts_1d_);
        auto Dval_3d = CArray <real_t> (num_verts_1d_, 3);

        // Calculate 1D basis for the Y coordinate of the point
        lagrange_basis_1D(val_1d, point(0));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            val_3d(i,0) = val_1d(i);
            val_1d(i) = 0.0;
        }


        // Calculate 1D partial w.r.t. eta for the Y coordinate of the point
        lagrange_derivative_1D(Dval_1d, point(1));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            Dval_3d(i,1) = Dval_1d(i);
            Dval_1d(i) = 0.0;
        }


        // Calculate 1D basis for the Z coordinate of the point
        lagrange_basis_1D(val_1d, point(2));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            val_3d(i,2) = val_1d(i);
            val_1d(i) = 0.0;
        }

        // Multiply the i, j, k components of the basis and partial_eta from each node
        // to get the tensor product partial derivatives of the basis at each node
        for(int k = 0; k < num_verts_1d_; k++){
            for(int j = 0; j < num_verts_1d_; j++){
                for(int i = 0; i < num_verts_1d_; i++){
                    
                    int vert_rlid = vert_rid(i,j,k);

                    // Partial w.r.t xi
                    partial_eta(vert_rlid) = val_3d(i, 0)*Dval_3d(j, 1)*val_3d(k, 2);

                }
            }
        }
    };


    void HexN::partial_mu_basis(CArray <real_t> &partial_mu, CArray <real_t> &point){


        auto val_1d = CArray <real_t> (num_verts_1d_);
        auto val_3d = CArray <real_t> (num_verts_1d_, 3);

        auto Dval_1d = CArray <real_t> (num_verts_1d_);
        auto Dval_3d = CArray <real_t> (num_verts_1d_, 3);

        // Calculate 1D basis for the X coordinate of the point
        lagrange_basis_1D(val_1d, point(0));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            val_3d(i,0) = val_1d(i);
            val_1d(i) = 0.0;
        }


        // Calculate 1D basis for the Y coordinate of the point
        lagrange_basis_1D(val_1d, point(1));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            val_3d(i,1) = val_1d(i);
            val_1d(i) = 0.0;
        }


        // Calculate 1D partial w.r.t. mu for the Z coordinate of the point
        lagrange_derivative_1D(Dval_1d, point(2));
        
        // Save the basis value at the point to a temp array and zero out the temp array
        for(int i = 0; i < num_verts_1d_; i++){
            
            Dval_3d(i,2) = Dval_1d(i);
            val_1d(i) = 0.0;
        }

        // Multiply the i, j, k components of the basis and partial_xi from each node
        // to get the tensor product partial derivatives of the basis at each node
        for(int k = 0; k < num_verts_1d_; k++){
            for(int j = 0; j < num_verts_1d_; j++){
                for(int i = 0; i < num_verts_1d_; i++){
                    
                    int vert_rlid = vert_rid(i,j,k);

                    // Partial w.r.t mu
                    partial_mu(vert_rlid) = val_3d(i, 0)*val_3d(j, 1)*Dval_3d(k, 2);

                }
            }
        }
    };



    void HexN::lagrange_basis_1D(
        CArray <real_t> &interp,    // interpolant from each basis
        const real_t &x_point){     // point of interest in element
                         
        
        // calculate the basis value associated with each node_i
        for(int vert_i = 0; vert_i < num_verts_1d_; vert_i++){ 
            
            real_t numerator = 1.0;         // placeholder numerator
            real_t denominator = 1.0;       // placeholder denominator
            real_t interpolant = 1.0;       // placeholder value of numerator/denominator
            

            for(int vert_j = 0; vert_j < num_verts_1d_; vert_j++){  // looping over the verts !=vert_i
                if (vert_j != vert_i ){
                    
                    // Calculate the numerator
                    numerator = numerator*(x_point - HexN_Verts_1d_(vert_j));
                    
                    // Calculate the denominator 
                    denominator = denominator*(HexN_Verts_1d_(vert_i) - HexN_Verts_1d_(vert_j));
                
                }//end if
                
                interpolant = numerator/denominator; // storing a single value for interpolation for node vert_i
                
            } // end looping over nodes != vert_i

            // writing value to vectors for later use
            interp(vert_i)   = interpolant;           // Interpolant value at given point

        } // end loop over all nodes
    } // end of Legrange_1D function

    void HexN::lagrange_derivative_1D(
        CArray <real_t> &derivative,    // derivative
        const real_t &x_point){         // point of interest in element

        for(int vert_i = 0; vert_i < num_verts_1d_; vert_i++){ // looping over the nodes
        

            real_t denominator = 1.0;       // placeholder denominator
            real_t num_gradient = 0.0;      // placeholder for numerator of the gradient
            real_t gradient = 0.0;

            for(int vert_j = 0; vert_j < num_verts_1d_; vert_j++){

                // std::cout<<"HexN 1D Vert "<<vert_j<< " = "<<HexN_Verts_1d_(vert_j)<<std::endl;
            }

            for(int vert_j = 0; vert_j < num_verts_1d_; vert_j++){  // looping over the nodes !=vert_i
                if (vert_j != vert_i ){

                    // Calculate the denominator that is the same for 
                    // both the basis and the gradient of the basis
                    denominator = denominator*(HexN_Verts_1d_(vert_i) - HexN_Verts_1d_(vert_j));
                    
                    real_t product_gradient = 1.0;
                    
                    // Calculate the numerator of the gradient
                    for(int N = 0; N < num_verts_1d_; N++){  // looping over the nodes !=vert_i
                        
                        if (N != vert_j && N != vert_i ){
                            product_gradient = product_gradient * (x_point - HexN_Verts_1d_(N));
                        }// end if
                    }//end for
                    
                    // Sum over the product of the numerator 
                    // contributions from each node
                    num_gradient += product_gradient; 
                
                }//end if
                
                gradient = (num_gradient/denominator); // storing the derivative of the interpolating function
            
            } // end looping over nodes != vert_i

            // writing value to vectors for later use
            derivative(vert_i)  = gradient;    // derivative of each function

        } // end loop over all nodes
    } // end of Legrange_1D function

    void HexN::create_lobatto_nodes(int element_order){

        int num_nodes_1d = 0;
        int num_nodes_3d = 0;

        if( element_order == 0){

            num_nodes_1d = 2;
            num_nodes_3d = pow(num_nodes_1d, 3);

        }

        else{
            num_nodes_1d = 2.0 * element_order + 1;
            num_nodes_3d = pow(num_nodes_1d, 3);
        }

        // --- build gauss nodal positions and weights ---
        // std::cout<< "Num Nodes passed to create lobatto nodes "<<std::endl;
        //elements::lobatto_nodes_1D(HexN_Nodes_1d_, num_nodes_1d);
        lobatto_nodes_1D(HexN_Nodes_1d_, num_nodes_1d);
        
        for(int num_k = 0; num_k < num_nodes_1d; num_k++){
            for(int num_j = 0; num_j < num_nodes_1d; num_j++){
                for(int num_i = 0; num_i < num_nodes_1d; num_i++){
        
                    int node_rlid = node_rid(num_i, num_j, num_k);

                    HexN_Nodes_(node_rlid, 0) = HexN_Nodes_1d_(num_i);
                    HexN_Nodes_(node_rlid, 1) = HexN_Nodes_1d_(num_j);
                    HexN_Nodes_(node_rlid, 2) = HexN_Nodes_1d_(num_k);
                }
            }
        }

        // Saving vertex positions in 1D
        if( element_order == 0){

            int vert_id = 0;
            for(int i = 0; i < num_nodes_1d; i++){

                HexN_Verts_1d_(vert_id) = HexN_Nodes_1d_(i);

                vert_id++;
            }  

        }

        else{
            
            int vert_id = 0;
            for(int i = 0; i < num_nodes_1d; i=i+2){

                HexN_Verts_1d_(vert_id) = HexN_Nodes_1d_(i);

                vert_id++;
            }  
        }
    }



/*
==========================
   4D Tesseract element
==========================

The finite element local point numbering for a 16 node Tesseract is
based on the 3D Hex8 Ensight element
 

                 _.15-------------------------------------14
            _.+<    |\                              . >-"/ |
      _ .+>         | \                         .>"" ./    |
  .>""              |  \                     <""    /      |
12----------------------+------------------13    ./        |
| )<=               |    \               / | _/""          |
|     )\+           |     \            / /"|               |
|         (\=       |   _. 7---------+--6  |               |
|             \>   .|+<    |       / . "|  |               |
|               '4--+------+------5'    |  |               |
|                |  |      |      |     |  |               |
|                |  |      |      |     |  |               |
|                |  |      |      |     |  |               |
|                |  |      |      |     |  |               |
|                |  |      |      |     |  |               |
|                |  |      |      |     |  |               |
|                |  |   _ .3------+-----2_ |               |
|                |  | "   /       |   /'  '| \= _          |
|                0--+---+---------1*"      |     ""\       |
|             ./'   |  "           \       |         "">   |
|            /      |/              \      |             ".|
|         /        11----------------+-----+--------------10
|      ./    .+<""                    )    |           .</
|    /(   /(                            \  |     _.+</
| ./  /"                                 \ |  >(
8------------------------------------------9'

              j
              ^        k
              |      /
              |    / 
              |  /
              |/
              +---------->i

            i = Xi
            j = Eta
            k = Mu
            t = Tau 

*/




real_t Tess16::ref_vert[ Tess16::num_verts* Tess16::num_dim] = // listed as {Xi, Eta, Mu, Tau}
    {
    // Interior cube bottom
    -1.0, -1.0, -1.0, -1.0,
    +1.0, -1.0, -1.0, -1.0,
    +1.0, -1.0, +1.0, -1.0,
    -1.0, -1.0, +1.0, -1.0,
    // Interior cube top
    -1.0, +1.0, -1.0, -1.0,
    +1.0, +1.0, -1.0, -1.0,
    +1.0, +1.0, +1.0, -1.0,
    -1.0, +1.0, +1.0, -1.0,
    // Exterior cube bottom
    -1.0, -1.0, -1.0, +1.0,
    +1.0, -1.0, -1.0, +1.0,
    +1.0, -1.0, +1.0, +1.0,
    -1.0, -1.0, +1.0, +1.0,
    // Exterior cube top
    -1.0, +1.0, -1.0, +1.0,
    +1.0, +1.0, -1.0, +1.0,
    +1.0, +1.0, +1.0, +1.0,
    -1.0, +1.0, +1.0, +1.0,
    };


// calculate a physical position in an element for a given xi,eta,mu
void Tess16::physical_position(
    ViewCArray <real_t> &x_point,
    const ViewCArray <real_t> &xi_point,
    const ViewCArray <real_t> &vertices){

    real_t basis_a[num_verts];
    auto basis = ViewCArray <real_t> (basis_a, num_verts);
    
    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts, num_dim);
   
    // calculate the shape functions from each vertex for (xi,eta,mu, tau)
    for(int this_vert = 0; this_vert < num_verts; this_vert++){
        basis(this_vert) = 1.0/16.0
            * (1.0 + xi_point(0)*ref_verts(this_vert, 0)) 
            * (1.0 + xi_point(1)*ref_verts(this_vert, 1)) 
            * (1.0 + xi_point(2)*ref_verts(this_vert, 2)) 
            * (1.0 + xi_point(3)*ref_verts(this_vert, 3));
    } // end for shape functions

    // calculate the position in physical space
    for (int dim = 0; dim < 4; dim++){
        x_point(dim) = 0.0;
    }

    for (int this_vert = 0; this_vert < 16; this_vert++ ){
        for (int dim = 0; dim < 4; dim++){
            x_point(dim) += vertices(this_vert, dim)*basis(this_vert);
        } // end for dim
    } // end for this_vert

} // End physical position function


// calculate the value for the basis at each node for a given xi,eta,mu,tau
void Tess16::basis(
    ViewCArray <real_t>  &basis,
    const ViewCArray <real_t>  &xi_point){

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts, num_dim);

    // calculate the basis functions from each vertex for (xi,eta,mu, tau)
    for(int this_vert = 0; this_vert < num_verts; this_vert++){
        basis(this_vert) = 1.0/16.0
            * (1.0 + xi_point(0)*ref_verts(this_vert, 0)) 
            * (1.0 + xi_point(1)*ref_verts(this_vert, 1)) 
            * (1.0 + xi_point(2)*ref_verts(this_vert, 2)) 
            * (1.0 + xi_point(3)*ref_verts(this_vert, 3));
    } // end for this_vert

}


// Partial derivative of shape functions with respect to Xi at Xi_point
void Tess16::partial_xi_basis(
    ViewCArray <real_t> &partial_xi, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts, num_dim);

    for (int this_vert = 0; this_vert < num_verts; this_vert++){
        partial_xi(this_vert) = 1.0/16.0
            * (ref_verts(this_vert, 0))
            * (1.0 + xi_point(1)*ref_verts(this_vert, 1))
            * (1.0 + xi_point(2)*ref_verts(this_vert, 2))
            * (1.0 + xi_point(3)*ref_verts(this_vert, 3));
    }   // end for this_vert 

} // end partial Xi function


// Partial derivative of shape functions with respect to Eta
void Tess16::partial_eta_basis(
    ViewCArray <real_t> &partial_eta, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts, num_dim);

    for (int this_vert = 0; this_vert < num_verts; this_vert++){  
        partial_eta(this_vert) = 1.0/16.0
            * (1.0 + xi_point(0)*ref_verts(this_vert, 0))
            * (ref_verts(this_vert, 1))
            * (1.0 + xi_point(2)*ref_verts(this_vert, 2))
            * (1.0 + xi_point(3)*ref_verts(this_vert, 3));               
    }   // end for this_vert 

}  // End partial eta function


// Partial derivative of shape functions with respect to Mu
void Tess16::partial_mu_basis(
    ViewCArray <real_t> &partial_mu, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts, num_dim);

    for (int this_vert = 0; this_vert < num_verts; this_vert++){  
        partial_mu(this_vert) = 1.0/16.0
            * (1.0 + xi_point(0)*ref_verts(this_vert, 0))
            * (1.0 + xi_point(1)*ref_verts(this_vert, 1))
            * (ref_verts(this_vert, 2))
            * (1.0 + xi_point(3)*ref_verts(this_vert, 3));
    } // end for this_vert 

} // end partial Mu fuction


// Partial derivative of shape functions with respect to Tau
void Tess16::partial_tau_basis(
    ViewCArray <real_t> &partial_tau, 
    const ViewCArray <real_t> &xi_point) {

    auto ref_verts = ViewCArray<real_t> (ref_vert, num_verts, num_dim);

    for (int this_vert = 0; this_vert < num_verts; this_vert++){  
        partial_tau(this_vert) = 1.0/16.0
            * (1.0 + xi_point(0)*ref_verts(this_vert, 0))
            * (1.0 + xi_point(1)*ref_verts(this_vert, 1))
            * (1.0 + xi_point(2)*ref_verts(this_vert, 2))
            * (ref_verts(this_vert, 3));
    } // end for this_vert   

} // End partial tau function

/* ----------------------------------------------------------------------
   choose the current 3D element type in the calculation
------------------------------------------------------------------------- */

void element_selector::choose_3Delem_type(elem_types::elem_type element_type, Element3D *&elem){

    switch(element_type)
    {
        
        // 3D element types
        case elem_types::Hex8:
        {
            elem = &Hex8_Object;

            //std::cout<<"Hex8 Chosen"<<std::endl;

            break;
        }

        case elem_types::Hex20:
        {
            elem = &Hex20_Object;

            //std::cout<<"Hex20 Chosen"<<std::endl;

            break;
        }

        case elem_types::Hex32:
        {
            elem = &Hex32_Object;

            //std::cout<<"Hex32 Chosen"<<std::endl;

            break;
        }

        case elem_types::HexN:
        {
            // elem = &HexN_elem;
            
            //std::cout<<"HexN Chosen"<<std::endl;

            break;
        }
        
        default : 
        {
            elem = &Hex8_Object;

            //std::cout<<"Default Hex8 Chosen"<<std::endl;

            break;
        }
    }
} // end choose element function

/* ----------------------------------------------------------------------
   choose the current 2D element type in the calculation
------------------------------------------------------------------------- */

void element_selector::choose_2Delem_type(elem_types::elem_type element_type, Element2D *&elem2D){

    switch(element_type)
    {
        // 2D element types
        // WARNING: DEFAULTS TO 3D Quad4
        case elem_types::Quad4:
        {   
            elem2D = &Quad4_Object;

            //std::cout<<"Quad4 Chosen"<<std::endl;

            break; 
        }
        
        case elem_types::Quad8:
        {
            elem2D = &Quad8_Object;

            //std::cout<<"Quad8 Chosen"<<std::endl;

            break;
        }
        
        case elem_types::Quad12:
        {
            elem2D = &Quad12_Object;

            //std::cout<<"Quad12 Chosen"<<std::endl;

            break;
        }
        
        case elem_types::QuadN:
        {
            // elem = &QuadN_elem;

            //std::cout<<"QuadN Chosen"<<std::endl;


            break;
        }
        
        default : 
        {
            elem2D = &Quad4_Object;

            //std::cout<<"Quad4 Chosen"<<std::endl;

            break; 
        }
    }
} // end choose element function

} // end namespace elements
